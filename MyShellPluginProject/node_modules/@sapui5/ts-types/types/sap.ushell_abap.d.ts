// For Library Version: 1.71.14declare namespace sap {  namespace ui2 {    namespace srvc {      /**       * @SINCE 1.19.0       */      class ODataService {        /**         * Constructs a facade to any OData service, providing token handling for SAP NetWeaver Gateway's token-based         * CSRF protection mechanism. See         * Cross-Site Request Forgery Protection.         */        constructor(          /**           * OData wrapper instance this service facade delegates to           */          oODataWrapper: sap.ui2.srvc.ODataWrapper,          fnDefaultFailure: undefined        );        /**         * @SINCE 1.7.0         *         * Returns the current value of the CSRF token. It is initially empty and determined automatically by `sap.ui2.srvc.ODataWrapper`         * on successful read requests.         * See:         * 	#refreshCsrfToken         * 	#setCsrfToken         */        getCsrfToken(): string;        /**         * @SINCE 1.19.0         *         * Opens a new queue where all requests are parked until a call to {@link #submitBatchQueue}.         */        openBatchQueue(): void;        /**         * @SINCE 1.17.0         *         * Refreshes the CSRF token of this OData service by reading the service document again, which is never         * cached. Called automatically by `sap.ui2.srvc.ODataWrapper` on a write operation if the CSRF token is         * missing or expired.         * See:         * 	#getCsrfToken         * 	#setCsrfToken         * 	sap.ui2.srvc.ODataWrapper#read         */        refreshCsrfToken(          /**           * a callback function that is executed if the request succeeds           */          fnSuccess: Function,          fnFailure: undefined        ): void;        /**         * @SINCE 1.7.0         *         * Determines the new value of the CSRF token. Use this function to synchronize the CSRF token across multiple         * instances of this facade in case their first read requests run in parallel. Retrieve the token from a         * service in the success handler of its read request and distribute it to all other services; do so for         * each service. Note that the last success handler of all first read requests run in parallel determines         * the token to be used for modifications.  If debugging HTTP traffic, watch out for `x-csrf-token` headers         * and `sap-XSRF_*` cookies.         * See:         * 	#getCsrfToken         * 	#refreshCsrfToken         */        setCsrfToken(          /**           * the new value of the CSRF token, which may be `null` or `undefined`           */          sNewCsrfToken?: string        ): void;        /**         * @SINCE 1.2.0         *         * Sets the default error handler for this facade.         */        setDefaultErrorHandler(fnNewDefaultFailure: undefined): void;      }      /**       * @SINCE 1.19.0       */      class ODataWrapper {        /** * Constructs a wrapper around `OData`, providing CSRF token handling, caching and generic batch support. * The sap-statistics header is automatically added to all requests if the URL query parameter `sap-statistics=true` * is set (see  * SAP Performance Statistics). If `OData` is missing, "sap.ui.thirdparty.datajs" is required automatically. *  The preferred way to call the constructor is from a "sub-class" of {@link sap.ui2.srvc.ODataService}: *  * ```javascript *   function Service() {    var oWrapper = new sap.ui2.srvc.ODataWrapper(oSettings, this);    sap.ui2.srvc.ODataService.call(this, oWrapper, fnDefaultFailure);  }  var myService = new Service();``` *  This provides public inheritance of `sap.ui2.srvc.ODataService` methods and private inheritance of `sap.ui2.srvc.ODataWrapper` * methods. In case you are not providing a public "sub-class" of `sap.ui2.srvc.ODataService` but only want * to use methods from `sap.ui2.srvc.ODataWrapper`, {@link sap.ui2.srvc.createODataWrapper} is the preferred * way to construct an instance. */        constructor(          /** * An object containing various properties:  * ```javascript *     {      baseUrl: "/OData/OData.svc", // Mandatory base URL of the OData service      supportsChangeSets: false,   // Type: boolean, Default: false                                   // Whether the OData service supports change sets with **multiple**                                   // operations bundled into a single logical unit of work. Otherwise                                   // each modifying operation is isolated in a change set of its own.      "sap-language": "EN",        // header which is set for all requests sent      "sap-client": 120,           // header which is set for all requests sent      "sap-statistics": true       // header which is set for all requests sent; in order to receive                                   // some performance statistics    }  ``` */          oSettings: object,          /**           * facade to any OData service, keeping track of CSRF token and default error handler (see {@link #getODataService})           */          oODataService: sap.ui2.srvc.ODataService        );        /**         * @SINCE 1.19.0         *         * Checks that the given callback functions are really functions. This check is useful to "fail fast" because         * these callbacks are not called immediately.         */        check(          /**           * success callback           */          fnSuccess: Function,          /**           * error callback           */          fnFailure: Function        ): void;        /**         * @SINCE 1.19.0         *         * Wrapper around `OData.request` which is able to automatically fetch a CSRF token if required. It uses         * POST as a method.         */        create(          /**           * a string containing the **relative** URL w.r.t. this OData wrapper's base URL, e.g. "Products"           */          sRelativeUrl: string,          /**           * payload of the request (in intermediate format)           */          oPayload: object,          /**           * callback function that is executed if the request succeeds, taking the processed data           */          fnSuccess: Function,          fnFailure: undefined        ): void;        /**         * @SINCE 1.19.0         *         * Wrapper around `OData.request` which is able to automatically fetch a CSRF token if required. It uses         * DELETE as a method.         */        del(          /**           * either a string containing the **relative** URL w.r.t. this OData wrapper's base URL, e.g. "Products(1)",           * or the datajs representation of the entity           */          vEntity: string | object,          /**           * callback function that is executed if the request succeeds, taking no data           */          fnSuccess: Function,          fnFailure: undefined        ): void;        /**         * @SINCE 1.30.0         *         *  Configures and activates session stickiness.   Session stickiness allows the client to execute         * OData requests to the same application server. This is achieved by copying a certain sticky session header         * (found in the OData response from the server) to the OData request made by ODataWrapper, indicating the         * load balancer that requests should be made against a certain application server. Once detected, the sticky         * header is automatically shared by all instances of `sap.ui2.srvc.ODataWrapper` connected to exactly the         * same base URL.   NOTE: The sticky session header sent from the server always overrides the last         * sticky session header requested. This is to avoid that the feature is disabled if the load balancer returns         * another value for the sticky session header for some reason (e.g. the application server goes offline).         *   NOTE: In line with {@link sap.ui2.srvc.PageBuildingService}, session stickiness is only supported         * in scopes different from PERS.   Currently, session stickiness is affected by the following limitations:         *         * 	 - If the client caches the response headers for certain requests, these cached headers will be used         * 			instead of the headers sent from the server (as in if cache was disabled).         * 	 - If initial requests to different URLs that share the same base URL are performed asynchronously (e.g.         * 			through multiple instances of ODataWrapper), sticky session may be disabled for a part or all of these         * 			initial requests. This is because the requests are made before the first response with a sticky session         * 			header is obtained.         * 	 - This mechanism only guarantees that requests are forwarded to the specified application server. For         * 			example, if the application server in turn contacts further load balanced servers, the session may not         * 			be maintain and load balancing may still occur.         */        enableStickySession(): void;        /**         * @SINCE 1.19.0         *         * Returns the wrapper's base URL.         */        getBaseUrl(): string;        /**         * @SINCE 1.19.1         *         * Returns this wrapper's facade to an OData service (which was passed to the constructor {@link sap.ui2.srvc.ODataWrapper}).         */        getODataService(): sap.ui2.srvc.ODataService;        /**         * @SINCE 1.34.0         *         * Checks whether the queue of requests is already open or not         * See:         * 	#openBatchQueue         * 	#submitBatchQueue         */        isBatchQueueOpen(): boolean;        /**         * @SINCE 1.30.0         *         * Checks whether session stickyness is configured and enabled         */        isStickySessionEnabled(): boolean;        /**         * @SINCE 1.19.0         *         * Wraps the given generic OData failure handler. It processes the raw OData error response object, calls         * the given failure handler with an error message and, since version 1.28.6, an object containing additional         * technical details. If a Deferred object is given, it is rejected with the same arguments passed to the         * failure handler call.         *         * This method logs technical information to the console if this is available at the time the error occurs.         */        onError(          /**           * the HTTP method used in the OData request, e.g. "POST"           */          sMethod: string,          /**           * the **absolute** URL the request is sent to           */          sRequestUrl: string,          fnFailure: undefined,          /**           * a `jQuery.Deferred` object that will be rejected with the same arguments fnFailure is called           */          oDeferred: any,          /**           * error object provided by datajs, should contain the response           */          oError: object        ): void;        /**         * @SINCE 1.19.0         *         * Opens a new queue where all requests are parked until a call to {@link #submitBatchQueue}.         * See:         * 	#isBatchQueueOpen         * 	#submitBatchQueue         */        openBatchQueue(): void;        /**         * @SINCE 1.19.0         *         * Wrapper around  `OData.read`         * which supports caching.         */        read(          /**           * a string containing the **relative** URL w.r.t. this OData wrapper's base URL, e.g. "Products(1)"           */          sRelativeUrl: string,          /**           * a callback function that is executed if the request succeeds, taking the processed data           */          fnSuccess: Function,          fnFailure: undefined,          /**           * whether the response is cached for further calls (since 1.11.0) in `OData.read.$cache`, a `sap.ui2.srvc.Map`           * from `sRequestUrl` to a `jQuery.Deferred` object created on demand; without this flag, the cache is neither           * written nor read!           */          bCache?: boolean        ): void;        /**         * @SINCE 1.19.0         *         * Submits the current batch queue opened by {@link #openBatchQueue} by sending a single "$batch" request         * to the OData service and deletes the current batch queue immediately.         * See:         * 	#openBatchQueue         * 	#isBatchQueueOpen         */        submitBatchQueue(          /**           * A callback function that is executed if the batch request is accepted by the server, no matter whether           * individual operations fail. It will be called **after** all success or failure handlers of individual           * operations.           */          fnBatchAccepted: Function,          fnBatchItselfFailed: undefined        ): void;        /**         * @SINCE 1.19.0         *         * Returns this wrapper's string representation.         */        // @ts-ignore        toString(          /**           * flag whether to show all properties           */          bVerbose?: boolean        ): string;        /**         * @SINCE 1.19.0         *         * Generic entity update method.         */        update(          /**           * the datajs representation of the entity           */          oEntity: object,          /**           * callback function that is executed if the request succeeds, taking no data           */          fnSuccess: Function,          fnFailure: undefined        ): void;        /**         * @SINCE 1.19.0         *         * Wrapper around `OData.request` which is able to automatically fetch a CSRF token if required. It uses         * POST as a method.         */        create(          /**           * a string containing the **relative** URL w.r.t. this OData wrapper's base URL, e.g. "Products"           */          sRelativeUrl: string,          /**           * payload of the request (in intermediate format)           */          oPayload: object,          fnFailure: undefined        ): void;        /**         * @SINCE 1.19.0         *         * Wrapper around `OData.request` which is able to automatically fetch a CSRF token if required. It uses         * DELETE as a method.         */        del(          /**           * either a string containing the **relative** URL w.r.t. this OData wrapper's base URL, e.g. "Products(1)",           * or the datajs representation of the entity           */          vEntity: string | object,          fnFailure: undefined        ): void;        /**         * @SINCE 1.19.0         *         * Wraps the given generic OData failure handler. It processes the raw OData error response object, calls         * the given failure handler with an error message and, since version 1.28.6, an object containing additional         * technical details. If a Deferred object is given, it is rejected with the same arguments passed to the         * failure handler call.         *         * This method logs technical information to the console if this is available at the time the error occurs.         */        onError(          /**           * the HTTP method used in the OData request, e.g. "POST"           */          sMethod: string,          /**           * the **absolute** URL the request is sent to           */          sRequestUrl: string,          fnFailure: undefined,          /**           * error object provided by datajs, should contain the response           */          oError: object        ): void;        /**         * @SINCE 1.19.0         *         * Submits the current batch queue opened by {@link #openBatchQueue} by sending a single "$batch" request         * to the OData service and deletes the current batch queue immediately.         * See:         * 	#openBatchQueue         * 	#isBatchQueueOpen         */        submitBatchQueue(fnBatchItselfFailed: undefined): void;        /**         * @SINCE 1.19.0         *         * Generic entity update method.         */        update(          /**           * the datajs representation of the entity           */          oEntity: object,          fnFailure: undefined        ): void;      }    }  }  interface IUI5DefineDependencyNames {    "sap/ui2/srvc/ODataService": undefined;    "sap/ui2/srvc/ODataWrapper": undefined;  }}