var fs = require("fs");
var path = require("path");
var DataType = require("./sap.ui.base/DataType");
var EnumValue = require("./EnumValue");
var Utils = require("./Utils");
"use strict";

//it contain all the UI5 library information by the version,
var _mMeta = {};
var _mLatestMetaVersion = '1.60.13';

//!!now the UI5 control/element metadata not contain the Aggregation for Element, as it is very stable, so just
//put the static value here for performance
var _mElementAggr= {
    customData: {
        Deprecated: false,
        multiple: true,
        type: "sap.ui.core.CustomData"
    },
    dependents: {
        Deprecated: false,
        multiple: true,
        type: "sap.ui.core.Control"
    },
    layoutData: {
        Deprecated: false,
        multiple: false,
        type: "sap.ui.core.LayoutData"
    },
    tooltip: {
        Deprecated: false,
        multiple: false,
        type: "sap.ui.core.TooltipBase"
    }
};

var _mControlProp = {
    busy: {
        Deprecated: false,
        type: "boolean",
        defaultValue: false
    },
    busyIndicatorDelay: {
        Deprecated: false,
        defaultValue: "1000",
        type: "int"
    },
    visible: {
        Deprecated: false,
        defaultValue: true,
        type: "boolean"
    }
};

var defaultCheckLib = [
    "sap.m.json",
    "sap.ui.core.json",
    "sap.ui.commons.json",
    "sap.ui.table.json",
    "sap.ui.layout.json",
    "sap.ui.comp.json",
    "sap.uxap.json"
];

var _NEO_APP_FILE_NAME = "neo-app.json";
var _WEBAPP_RESOURCES_PATH = "/webapp/resources";
var _RESOURCES_PATH = "/resources";

function _routeHasResourcesOrWebappResourcesPath(oRoute) {
    return oRoute.path === _RESOURCES_PATH || oRoute.path === _WEBAPP_RESOURCES_PATH;
}


function getVersions() {
    var ui5VersionsFolder = path.join(__dirname, '..', 'ui5Versions');
    return fs.readdirSync(ui5VersionsFolder).filter(function (file) {
        return fs.statSync(path.join(ui5VersionsFolder, file)).isDirectory();
    });
}

function getSortVersionsArray(aVersions) {
    //console.log('non sorted versions: ' + versions);
    var sortedVersions = aVersions.map( a => a.replace(/\d+/g, n => +n+100000 ) ).sort()
        .map( a => a.replace(/\d+/g, n => +n-100000 ) );
    //console.log('sorted versions: ' + sortedVersions);
    return sortedVersions;
}

function getMostSuitableVersion(aVersions, sVersion) {
    var versionIndex = aVersions.indexOf(sVersion);
    if (versionIndex > -1) {
        return aVersions[versionIndex];
    } else {
        //if version is not in the local list of versions, then
        //try to find the closest version from the list
        var allVersions = aVersions.slice();//copy the array
        allVersions.push(sVersion);
        var sortedVersions = getSortVersionsArray(allVersions);
        var versionIndex = sortedVersions.indexOf(sVersion);
        if (versionIndex === 0) {
            throw new Error('ui5 syntax check is only supported for version ' + sortedVersions[1] + ' or higher');
        }
        else {// > 0. return the previous version exists
            return sortedVersions[versionIndex - 1];
        }
    }
}

function getActiveVersion(validationMetadata) {
    var rootFolder = validationMetadata ? validationMetadata.getRootPath() : process.cwd();
    var neoAppPath = path.join(rootFolder, _NEO_APP_FILE_NAME);
    if (fs.existsSync(neoAppPath)) {
        var neoAppContent = fs.readFileSync(neoAppPath);
        var oNeoappContent;
        try {
            oNeoappContent = JSON.parse(neoAppContent);
        } catch (e) {
            throw new Error('failed reading ui5 version from neo-app.json file. ' + e.message);
        }
        if (oNeoappContent && oNeoappContent.routes) {
            // Check only routes with "/webapp/resources" or only routes with "/resources" path (first one wins)
            var oRoute = oNeoappContent.routes.find(n => _routeHasResourcesOrWebappResourcesPath(n));
            if (!oRoute) {
                return _mLatestMetaVersion;
            }
            var aFilteredRoutes = oNeoappContent.routes.filter(n => n.path === oRoute.path);
            var aVersions = getVersions();
            // Iterate filtered routes - there might be multiple routes with same path
            //the version is decided according to the first one which contains target information
            //code is copied from webide logic in UI5LibraryMetadataFromHcp.js
            for (var i = 0; i < aFilteredRoutes.length; i++) {
                if (aFilteredRoutes[i].target) {
                    // In case version property does not exist - return active version
                    if (!aFilteredRoutes[i].target.hasOwnProperty("version")) {
                        // get ui5 active version and return it
                        return _mLatestMetaVersion;
                    }
                    // Version property exists - check if version is available
                    var sVersion = aFilteredRoutes[i].target.version;
                    return getMostSuitableVersion(aVersions, sVersion);
                }
            }
        } else {
            return _mLatestMetaVersion;
        }
    }
    return _mLatestMetaVersion;
}


function readFiles(dirname, onFileContent, onError) {
    var filenames = fs.readdirSync(dirname);
    filenames.forEach(function (filename) {
        var content = fs.readFileSync(dirname + '/' + filename);
        onFileContent(filename, content);
    });
}

function merge(objs) {
    var obj = {},
        i = 0,
        il = objs.length,
        key;
    var num = 0;
    for (; i < il; i++) {
        for (key in objs[i]) {
            num++;
            if (objs[i].hasOwnProperty(key)) {
                obj[key] = objs[i][key];
            }
        }
    }
    return obj;
}

module.exports = {

    loadMetadata: function (validationMetadata) {
        var requiredVersion = getActiveVersion(validationMetadata);
        _mMeta[requiredVersion] = {
            enums: {},
            metadatas: {}
        };
        var metas = [];
        var enums = [];

        var ui5VersionLocation = path.join(__dirname, '..', 'ui5Versions', requiredVersion);
        readFiles(ui5VersionLocation, function (filename, content) {
            var json = JSON.parse(content);
            metas.push(json.metadatas || []);
            enums.push(json.enums || []);
        }, function (err) {
            throw err
        });
        _mMeta[requiredVersion].metadatas = merge(metas);
        _mMeta[requiredVersion].enums = merge(enums);
        return {
            version: requiredVersion,
            metadata: _mMeta[requiredVersion]
        };
    },

    /**
     * Get metadata for the control or element
     *
     * @param  {[type]} mMetadata:  The metadata for the project UI5 version
     * @param  {[type]} controlOrElementName
     * @return {[type]} The UI5 metadata for the control or element name
     */
    getMetadataByName: function (mMetadata, controlOrElementName) {
        return mMetadata.metadatas[controlOrElementName];
    },

    /**
     * Get the aggregation metadata for the controls's aggregation name
     * @param  {[type]} mMetadata            [description]
     * @param  {[type]} controlOrElementName [description]
     * @param  {[type]} aggregationNodeName  [description]
     * @return {[type]}                      [description]
     */
    getAggregationMetadata: function (mMetadata, controlOrElementName, aggregationNodeName) {
        if (mMetadata.metadatas[controlOrElementName]) {
            //Now the aggregations not contain the Element part, so need add here
            var mAggr = mMetadata.metadatas[controlOrElementName]["aggregations"];
            if (aggregationNodeName in mAggr) {
                return mAggr[aggregationNodeName];
            } else {
                //Try to get from the Element
                return _mElementAggr[aggregationNodeName];
            }
        }

        return null;
    },

    /*
     * Check whether it is a valid aggregation name or not
     */
    isValidAggregationName: function (mMetadata, controlOrElementName, aggregationNodeName) {
        var md = this.getAggregationMetadata(mMetadata, controlOrElementName, aggregationNodeName);
        if (md == null) {
            //if parent can't find the metadata, then no need check
            var controlMeta = this.getMetadataByName(mMetadata, controlOrElementName);
            if (!controlMeta) {
                return true;
            }
            else {
                return false;
            }
        } else {
            return true;
        }
    },

    /*
     * Check whether the aggregation is deprecated or not
     */
    isAggregationDeprecated: function (mMetadata, controlOrElementName, aggregationNodeName) {
        var md = this.getAggregationMetadata(mMetadata, controlOrElementName, aggregationNodeName);
        if (md && md.DeprecatedInfo) {
            return md.DeprecatedInfo;
        } else {
            return {
                isDeprecated: false
            };
        }
    },

    /*
     * Check whether teh control is deprecated or not
     */
    isControlDeprecated: function (mMetadata, controlOrElementName) {
        var md = mMetadata.metadatas[controlOrElementName];
        if (md && md.DeprecatedInfo) {
            return md.DeprecatedInfo;
        } else {
            return {
                isDeprecated: false
            };
        }
    },

    /**
     * Private function: check whether the control is instance of the type name
     * @param  {[type]}  mMetadata [description]
     * @param  {[type]}  ctrlName  [description]
     * @param  {[type]}  typeName  [description]
     * @return {Boolean} : true if is instance of, otherwise false
     */
    _isInstanceOf: function (mMetadata, ctrlName, typeName) {
        //!!some is interface, but now UI5 metadata not support it , so currently need ignore it
        var md = this.getMetadataByName(mMetadata, typeName);
        if (!md) {
            return true;
        }
        //first check itself, if not then check it's parent extend: "sap.ui.core.Control"
        if (ctrlName == typeName) {
            return true;
        } else {
            //only reach to the topMost class: "sap.ui.core.Element" for performance
            if (ctrlName != EnumValue.StrElement) {
                var md = this.getMetadataByName(mMetadata, ctrlName);
                if (md) {
                    var extend = md.extend;
                    return this._isInstanceOf(mMetadata, extend, typeName);
                } else {
                    //!! if can't get that,then by default just ignore it
                    return true;
                }
            }
        }

        return false;
    },

    /**
     * Check whether the control is a validate candidate for a control's aggregation,
     *      such as for the Table, the sap.ui.table.Column is a valid candidate for the Columns aggregation node
     * @param  {[type]}  mMetadata            [description]
     * @param  {[type]}  controlOrElementName [description]
     * @param  {[type]}  aggregationNodeName  [description]
     * @param  {[type]}  candidateName        [description]
     * @return {Boolean}                      [description]
     */
    isValidAggregationCandidate: function (mMetadata, controlOrElementName, aggregationNodeName, candidateName) {
        var md = this.getAggregationMetadata(mMetadata, controlOrElementName, aggregationNodeName);
        //now candidateName like sap.ui.table.TreeTable,
        if (md) {
            //type like sap.ui.table.Table
            var type = md.type;

            return this._isInstanceOf(mMetadata, candidateName, type);
        }

        return false;
    },


    /**
     * Get the meta data type ( Agrr, Prop, Asso,Event ) and the meta data
     * @param  {[type]} mMetadata            [description]
     * @param  {[type]} controlOrElementName [description]
     * @param  {[type]} metaName             [description]
     * @return {[type]} : {
         *                    metaType: value in EnumValue.MetaType,
         *                    metaData: the map of the detail property of the Prop/Event/Asso
         *                    }
     */
    getMetaTypeAndMetaData: function (mMetadata, controlOrElementName, metaName) {
        var md = mMetadata.metadatas[controlOrElementName];

        var ret = {
            metaType: EnumValue.MetaType.Unknown,
            metaData: null
        };

        if (!md) {
            return ret;
        }

        //first try to get from itself, if not then find from parent,until reach to the Control or element
        if (metaName in md.properties) {
            ret.metaType = EnumValue.MetaType.Prop;
            ret.metaData = md.properties[metaName];
        } else if (metaName in md.aggregations) {
            ret.metaType = EnumValue.MetaType.Aggr;
            ret.metaData = md.aggregations[metaName];
        } else if (metaName in md.associations) {
            ret.metaType = EnumValue.MetaType.Asso;
            ret.metaData = md.associations[metaName];
        } else if (metaName in md.events) {
            ret.metaType = EnumValue.MetaType.Event;
            ret.metaData = md.events[metaName];
        }

        if (ret.metaType != EnumValue.MetaType.Unknown) {
            return ret;
        } else {
            //try to get from parent, until reach to top most
            if (controlOrElementName == EnumValue.StrManagedObject) {
                //still can't find, no need check parent any more
                return ret;
            } else {
                var parentName = md.extend;
                return this.getMetaTypeAndMetaData(mMetadata, parentName, metaName);
            }
        }
    },

    /**
     * Check the semantic of the property value, mainly based on the metadata type
     * @param  {[type]} name        : property name
     * @param  {[type]} value       : property value
     * @param  {[type]} propMeta    : the meta data for the property
     * @param  {[type]} controlMeta : the meta dat for the control, it is needed when do the auto fix
     * @param  {[type]} mMetadata: The metadata for current version
     * @return {[type]}           return [] means no error, else return the array: [msgId, arg0, arg1, arg2, arg3]
     */
    checkPropertyValue: function (name, oValue, propMeta, controlMeta, mMetadata) {
        //Here check for the enum value first
        if (Utils.startsWith(propMeta.type, "sap.")) {
            var mEnum = mMetadata.enums[propMeta.type];
            //some basic type like the sap.ui.core.CSSSize will not find in enums, so it will do the normal check
            if (mEnum) {
                //here normal case is a enum value not correct, then we also try to get the correct value
                if (oValue in mEnum) {
                    return [];
                } else {
                    //Invalid property value <{0}> for enum type <{1}> of property <{3}>.
                    //!!here can use the string similary check to get the most matched case
                    return ["XML_INVALID_PROPERTY_ENUM_VALUE", oValue, propMeta.type, name];
                }
            }
        }

        var oType = DataType.getType(propMeta.type);

        // If property has an array type, clone the array to avoid modification of original data
        /* if (oType instanceof sap.ui.base.DataType && oType.isArrayType() && jQuery.isArray(oValue)) {
             oValue = oValue.slice(0);
         }*/

        // In case null is passed as the value return the default value, either from the property or from the type
        if (oValue === null || oValue === undefined) {
            //just pass
        } else if (oType instanceof DataType) {
            // Implicit casting for string only, other types are causing errors

            if (oType.getName() == "string") {
                // if (!(typeof oValue == "string" || oValue instanceof String)) {
                //  oValue = "" + oValue;
                // }
            } else if (oType.getName() == "string[]") {
                // For compatibility convert string values to array with single entry
                // if (typeof oValue == "string") {
                //     oValue = [oValue];
                // }
                // if (!jQuery.isArray(oValue)) {
                //     //Invalid property value: {0} is type {1}, expected {2} for property {3}. Please enter the correct value for the mode type.
                //     return ["XML_INVALID_PROPERTY_VALUE", oValue, typeof oValue, "string[]", name];
                // }
            } else {
                //here the value is string like "true", so need covnert to to the corresponding data type,
                var parsedValue = null;
                //but for the enum type can't use the parseValue as it will return null, then the prompt willl lost real value
                if (Utils.startsWith(propMeta.type, "sap.")) {
                    // if (parseValue == null) {
                    //  parseValue = oValue;
                    // }
                    parsedValue = oValue;
                } else {
                    parsedValue = oType.parseValue(oValue);
                }

                //??need check for the enum value
                if (!oType.isValid(parsedValue)) {
                    //here normal case is a enum value not correct, then we also try to get the correct value
                    return ["XML_INVALID_PROPERTY_VALUE", oValue, typeof oValue, oType.getName(), name];
                }
            }
        }

        return [];
    }
};
