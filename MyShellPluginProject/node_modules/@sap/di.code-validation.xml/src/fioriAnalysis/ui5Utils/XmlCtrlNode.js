if (typeof define !== 'function') {var define = require('amdefine')(module)};

/**
 * This class will hold the information for a xml control node, it inherit from TreeNode so can easily get the children
 */
define([
		"./EnumValue", "./Ui5MetadataMng", "./Utils", "./semanticChecks"
	],
function(EnumValue, Ui5MetadataMng, Utils, Config) {

	function XmlCtrlNode(metadata) {

		//!! all start by node in order to avoid confilct
		//the control name, such as sap.m.Button
		this.nodeName = metadata.nodeName;
		this.nodeType = metadata.nodeType;
		this.isFragment = metadata.isFragment;//only valid for the RootNode
		this.tagName = metadata.tagName;
		this.parent = null;

		//--line and column infor for the node, now only use the position
		// lineStart : { type: 'int'},
		// lineEnd : { type: 'int'},
		// colStart:    { type:  'int'},
		// colEnd:    { type:  'int'},
		var position = metadata.position; //format defined in customerXmlParse,

		this.init();

		this.getNodeName = function() {
			return this.nodeName;
		};
		this.setNodeName = function(_nodeName) {
			this.nodeName = _nodeName;
		};
		this.getPosition = function() {
			return this.position;
		};
		this.setPosition = function(columnNumber,lineNumber) {
			this.position = {
				column:	columnNumber,
				line: lineNumber
			};
		};
		this.getNodeType = function() {
			return this.nodeType;
		};
		this.setNodeType = function(_nodeType) {
			this.nodeType = _nodeType;
		};
		this.getIsFragment = function() {
			return this.isFragment;
		};
		this.setIsFragment = function(_isFragment) {
			this.isFragment = _isFragment;
		};
		this.getTagName = function() {
			return this.tagName;
        };

		//=============some help function for the node type
		this.isRootNode = function() {
			return this.getNodeType() == EnumValue.NodeType.Root;
		};

		//!!!! only have meaning for top node
		this.isFragment = function() {
			return this.getIsFragment();
		};

		this.isHtmlNode = function() {
			return this.getNodeType() == EnumValue.NodeType.Html;
		};

		this.isUi5Node = function() {
			return this.getNodeType() == EnumValue.NodeType.Ui5;
		};

		this.isTemplateNode = function() {
			return this.getNodeType() == EnumValue.NodeType.Template;
		};

		this.isUi5FragmentNode = function(  ) {
			return this.isUi5Node() && this.getNodeName() === EnumValue.StrFragment;
		};

		this.isUi5ExtPoint = function( evt ) {
			return this.isUi5Node() && this.getNodeName() === EnumValue.StrExtPoint;
		};

		this.isRootOrHtmlNode = function() {
			return this.getNodeType() == EnumValue.NodeType.Root || this.getNodeType() == EnumValue.NodeType.Html;
		};

		this.isAggrNode = function() {
			return (this.getNodeType() == EnumValue.NodeType.Aggr);
		};

		this.isAggrNodeOfName = function(name) {
			return (this.getNodeType() == EnumValue.NodeType.Aggr) &&
				   (name == this.getNodeName());
		};

	}

	XmlCtrlNode.prototype.init = function() {
	    this._mMeta = {};
		this._nodes = [];
	};

	XmlCtrlNode.prototype.addNode = function(node) {//added for server impl
	    this._nodes.push(node);
		node.parent = this;
	};

	XmlCtrlNode.prototype.getParent = function() {//added for server impl
	    return this.parent;
	};

	XmlCtrlNode.prototype.getNodes = function() {//added for server impl
	    return this._nodes;
	};

	XmlCtrlNode.prototype.addMetaData = function(attributeName, value, columnNumber, lineNumber ) {
		this._mMeta[attributeName] = {
			value: value,
			column: columnNumber,
			line: lineNumber
        };
	};

	XmlCtrlNode.prototype.addIssue = function(mGlobal,line, column, msgId,arg0, arg1, arg2,arg3) {
		var msg = Utils.getText(msgId, [arg0, arg1, arg2,arg3]);
	    var issue = {
			category: "Semantic Error",  //??here need set different category
            checker:"SAPUI5",
            helpUrl: "https://help.hana.ondemand.com/webide/frameset.htm?c2b013a1cf8148d2991e59bf707b3ffe.html",
            line:   line,
            column: column,
            message: msg,
            source: "",
            path: mGlobal.filePath,
			severity: this._getIssueSeverity(msgId),
			id: msgId,
			tagName: this.tagName.substr(this.tagName.indexOf(":") + 1).toLowerCase()
		};
		mGlobal.issues.push( issue);
	};

	XmlCtrlNode.prototype._getIssueSeverity = function(msgId){
	var errors = [
		"XML_DUPLICATE_ID",
		"XML_INVALID_PROPERTY_ENUM_VALUE",
		"XML_INVALID_AGGR_NODE",
		"XML_INVALID_MULTIPLICITY",
		"XML_INVALID_PROPERTY_NAME",
		"XML_INVALID_ID",
		"XML_INVALID_PROPERTY_VALUE",
		"XML_INVALID_ASSOCIATION_VALUE",
		"XML_INVALID_FORMATTER_FUNC",
		"XML_INVALID_EVENT_FUNC",
		"XML_MISSING_STABLE_ID"
		];

		if(errors.indexOf(msgId) > -1){
			return "error";
		}else{
			return "warning";
		}

	};

	XmlCtrlNode.prototype.addNodeIssue =  function(mGlobal, msgId, arg0, arg1, arg2, arg3) {
		var position = this.getPosition();
		this.addIssue(mGlobal, position.line, position.column,
			msgId, arg0, arg1, arg2,arg3);
	};

	/**
	 * Add all the metadata issue:
	 * @param {[type]} mGlobal 			[description]
	 * @param {[type]} attributeName    [description]
	 * @param {[type]} msgId   			[description]
	 * @param {[type]} arg0    			[description]
	 * @param {[type]} arg1    			[description]
	 * @param {[type]} arg2    			[description]
	 * @param {[type]} arg3    			[description]
	 */
	XmlCtrlNode.prototype.addMetaIssue = function(mGlobal, attributeName, msgId, arg0, arg1, arg2,arg3) {
		var nodePos = this.getPosition();
		//tag name length is added so the error will appear after the tagname when the attr isn't defined
		var column = this._mMeta[attributeName] ? this._mMeta[attributeName].column :  nodePos.column+this.getTagName().length ;
		var line =  this._mMeta[attributeName] ? this._mMeta[attributeName].line : nodePos.line;
		this.addIssue(mGlobal, line, column,
			msgId, arg0, arg1, arg2,arg3);
	};


	/**
	 * Check the syntax and semantic for node
	 * @param  {[type]} mGlobal: which will hold some information need considerate for all the node,
	 *               such as the id then need sure no duplidate
	 * @return {[type]}      [description]
	 */
	XmlCtrlNode.prototype.checkSemantic =  function( mGlobal ) {
	    this.checkSemantic_NodeSelf(mGlobal);
	    this.checkSemantic_Meta(mGlobal);

	    //then the sub nodes
	    var nodes = this.getNodes();
		for ( var i = 0; i < nodes.length; i++) {
			var node = nodes[i];
			node.checkSemantic(mGlobal);
		}
	};

	XmlCtrlNode.prototype.checkSemantic_Meta_Prop = function( mGlobal, attributeName, value, propMeta, controlMeta) {
		//check deprecation for property
		if (propMeta.DeprecatedInfo.isDeprecated) {
			this.addMetaIssue(mGlobal, attributeName, "XML_DEPRECATED_PROPERTY", attributeName, this.getNodeName(),
			propMeta.DeprecatedInfo.since, this._retriveTextFromHtml(propMeta.DeprecatedInfo.description) || "");
		}
	    var binding = Utils.parseBindingInfor(value);
	    if ( binding.paths && binding.paths != "") {
			if ( ! Utils.isValidBindingPath(binding.paths))  {
				this.addMetaIssue(mGlobal, attributeName, "XML_INVALID_BINDING_PATH");
			}

			if (binding.formatter && binding.formatter != "") {
				if ( ! Utils.isValidFunction(binding.formatter))  {
					this.addMetaIssue(mGlobal, attributeName, "XML_INVALID_FORMATTER_FUNC");//parameter removed not used in i18n - binding.formatter);
				}
			}
			return;
		}

		var retArr = Ui5MetadataMng.checkPropertyValue(attributeName, value, propMeta, controlMeta, mGlobal.metaData);
		if (retArr.length >0) {
			this.addMetaIssue(mGlobal, attributeName,retArr[0], retArr[1],retArr[2],retArr[3],retArr[4]);
		}

	};

	XmlCtrlNode.prototype.checkSemantic_Meta_Event = function( mGlobal, attributeName, value, metaData  ) {
		//check deprecation for event
		if (metaData.DeprecatedInfo.isDeprecated) {
			this.addMetaIssue(mGlobal, attributeName, "XML_DEPRECATED_EVENT", attributeName, this.getNodeName(),
			metaData.DeprecatedInfo.since, this._retriveTextFromHtml(metaData.DeprecatedInfo.description) || "");
		}
		if ( !Utils.isValidEventFunction(value)) {
			this.addMetaIssue(mGlobal, attributeName, "XML_INVALID_EVENT_FUNC");//parameter removed not used in i18n - value);
		}
	};

	XmlCtrlNode.prototype.checkSemantic_Meta_Asso = function( mGlobal, attributeName, value, metaData  ) {
		//for the Associatin, the id must existed, but it maybe before the corresponding control, so here just check the id is valid
		var aAssociatinValues = value.split(",");
		for(var i=0; i<aAssociatinValues.length; i++){
			aAssociatinValues[i] = aAssociatinValues[i].trim(); //Removes leading and trailing whitespace or specified characters from string.
			if ( ! Utils.isValidId(aAssociatinValues[i])) {
				this.addMetaIssue(mGlobal, attributeName, "XML_INVALID_ASSOCIATION_VALUE");
			}
		}
	};

	XmlCtrlNode.prototype.checkSemantic_Meta_Aggr = function( mGlobal, attributeName, value, metaData  ) {
	    //here later we can add check for the binding path of  the aggregation, or the normal string for the alterType such as string
	};

	XmlCtrlNode.prototype.checkSemantic_Meta = function( mGlobal ) {
		//first need ensure can get the metadata for this control
		var controlMeta = Ui5MetadataMng.getMetadataByName(mGlobal.metaData, this.getNodeName());
		if (this.isTemplateNode()){
			return;
		}

		if (!controlMeta){
			return;
		}
		if(mGlobal.IdAttributeRequired && !this._mMeta.hasOwnProperty("id")){
			this.addMetaIssue(mGlobal, Utils.getLastPart(this.getNodeName()), "XML_MISSING_STABLE_ID");
		}
		for (var attributeName in this._mMeta) {
			var value = this._mMeta[attributeName].value;

			//for the id and class, can check it without the metadata
			if (attributeName == 'id') {
				if ( ! Utils.isValidId(value)) {
					this.addMetaIssue(mGlobal, attributeName, "XML_INVALID_ID");
				}

				if ( mGlobal.aId.indexOf( value ) === -1 ) {
					mGlobal.aId.push( value );
				} else {
					if ( Config.isCheckPointEnabled( EnumValue.CheckPoint.DuplicateId)) {
						this.addMetaIssue(mGlobal, attributeName, "XML_DUPLICATE_ID");
					}
				}
				continue;
			} else if (attributeName == "class") {
				if ( ! Utils.isValidCssClass(value)) {
					this.addMetaIssue(mGlobal, attributeName, "XML_INVALID_CSS");
				}
				continue;
			}else if (attributeName === 'binding' || attributeName === 'fragmentName' || attributeName === 'stashed') {
				//as the binding is special property, which not provided in the metadata, so just ingore it
				continue;
			}

			var metaInfo = Ui5MetadataMng.getMetaTypeAndMetaData(mGlobal.metaData, this.getNodeName(), attributeName);

			if (metaInfo.metaType == EnumValue.MetaType.Unknown) {
				//now it may like customData:persoKey, in UI5 it will add customer data, so just do simple check
				if ( attributeName.indexOf(":") == -1) {
					this.addMetaIssue(mGlobal, attributeName, "XML_INVALID_PROPERTY_NAME", attributeName);
				}
				//!!here  can add the auto check solution
			} else if (metaInfo.metaType == EnumValue.MetaType.Prop) {
				this.checkSemantic_Meta_Prop( mGlobal,attributeName,value, metaInfo.metaData, controlMeta);
			} else if (metaInfo.metaType == EnumValue.MetaType.Asso) {
				this.checkSemantic_Meta_Asso( mGlobal,attributeName,value, metaInfo.metaData);
			} else if (metaInfo.metaType == EnumValue.MetaType.Event) {
				this.checkSemantic_Meta_Event( mGlobal,attributeName,value, metaInfo.metaData);
			} else if (metaInfo.metaType == EnumValue.MetaType.Aggr) {
				this.checkSemantic_Meta_Aggr( mGlobal,attributeName,value, metaInfo.metaData);
			}
		}
	};


	/**
	 * Check the semantic error for the node itself
	 * @param  {[type]} mGlobal [description]
	 * @return {[type]}         [description]
	 */
	XmlCtrlNode.prototype.checkSemantic_NodeSelf = function( mGlobal ) {
		var parentMeta;
		var parent;
		var aggrInfo;

		//now for template node just ignore it
		if ( this.isTemplateNode()){
			return;
		}

		//first need ensure can get the metadata for the ui5 control
		if ( this.isUi5Node()) {
			var controlMeta = Ui5MetadataMng.getMetadataByName(mGlobal.metaData, this.getNodeName());
			if (!controlMeta){
				return;
			}
		}

	    if (this.isRootNode()) {
	    	//now for root node no need check
	    } else if ( this.isAggrNode()) {
	    	parent = this.getParent();

	    	if ( !parent.isUi5Node()) {
	    		this.addNodeIssue(mGlobal, "XML_INVALID_AGGR_NODE", this.getParent().getNodeName());
	    	}
	    	var bValidAggrNodeName = Ui5MetadataMng.isValidAggregationName(mGlobal.metaData,
	    		this.getParent().getNodeName(), this.getNodeName());

	    	if (  !bValidAggrNodeName) {
	    		//node name is not valid,
				this.addNodeIssue(mGlobal, "XML_INVALID_AGGR_NODE", this.getParent().getNodeName());
	    	} else {
	    		//check the Aggr deprecated
	    		if (  Config.isCheckPointEnabled( EnumValue.CheckPoint.Deprecated)) {
	    			var oDeprecatedAggregation = Ui5MetadataMng.isAggregationDeprecated(mGlobal.metaData, this.getParent().getNodeName(), this.getNodeName());
					if (oDeprecatedAggregation.isDeprecated) {
						this.addNodeIssue(mGlobal, "XML_DEPRECATED_AGGREGATION", this.getNodeName(),
							this.getParent().getNodeName(), oDeprecatedAggregation.since, this._retriveTextFromHtml(oDeprecatedAggregation.description) || "");
					}
	    		}
	    	}

	    } else if ( this.isUi5Node()) {
	    	//check whether is valid candidate for the parent node
	    	if ( this.isUi5FragmentNode() || this.isUi5ExtPoint() ) {
	    		//for the fragment it is very difficult  to get the real code so now just ignore it
	    	} else {

	    		if (  Config.isCheckPointEnabled( EnumValue.CheckPoint.Deprecated)) {
	    			var oDeprecatedControl = Ui5MetadataMng.isControlDeprecated(mGlobal.metaData, this.getNodeName());
					if (oDeprecatedControl.isDeprecated) {
						this.addNodeIssue(mGlobal, "XML_DEPRECATED_CONTROL", this.getNodeName(),
							this.getParent().getNodeName(), oDeprecatedControl.since, this._retriveTextFromHtml(oDeprecatedControl.description) || "");
					}
	    		}

		    	parent = this.getParent();
		    	if ( parent.isAggrNode()) {
					//!!now there are some controls which implemented itself logic for Aggr, for example the
					// SemanticPage.prototype.addCustomFooterContent , then it means even the customFooterContent type is sap.m.Button
					// but now it can add all the controls, for this case just maintain it in cfg,
					if ( Config.isSpecialAggregationNode( parent.getNodeName())){
						return ;
					}

		    		var parentParent = parent.getParent();
		    		if ( !parentParent.isUi5Node()) {
		    			//it should not happens and have been report by parent node
		    			return;
		    		}

					var aggrInfo =  Ui5MetadataMng.getAggregationMetadata(mGlobal.metaData,
							parentParent.getNodeName(), parent.getNodeName());
					if (aggrInfo) {
						var bValidCandidate = Ui5MetadataMng.isValidAggregationCandidate(mGlobal.metaData,
							parentParent.getNodeName(),
							parent.getNodeName(),
							this.getNodeName() );

						if (!bValidCandidate) {
							this.addNodeIssue(mGlobal, "XML_INVALID_CANDIDATE",
								parentParent.getNodeName(), aggrInfo.type);
						}

						//also can check whether it is not multiple but put several nodes
						if ( !aggrInfo.multiple) {
							if ( parent.getNodes().length > 1) {
								//it don't allow multiple, so only report from the seconds
								if ( this != parent.getNodes()[0]) {
									this.addNodeIssue(mGlobal, "XML_INVALID_MULTIPLICITY",
										parent.getNodeName(), parent.getNodes().length);
								}
							}
						}
					} //if (aggrInfo) {
		    	} //end of if ( parent.isAggrNode())
		    	else {
		    		//!!As now from the metadata can't get the default Aggregation name, so can't do check for this case
		    	}
	    	}
	    }
	};

	XmlCtrlNode.prototype._retriveTextFromHtml = function(value) {
		if (value) {
			return value.replace(/<(?:.|\n)*?>/gm, '');
		}
	};
	return XmlCtrlNode;
});
