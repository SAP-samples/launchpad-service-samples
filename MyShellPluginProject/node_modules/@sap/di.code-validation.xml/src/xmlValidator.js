var domParser = require('xmldom').DOMParser;
var fioriAnalysis = require('./fioriAnalysis');
var utils = require('./fioriAnalysis/ui5Utils/Utils');
var domHandler = require('./lib/domhandler/domhandler').DOMHandler;
var coreLibs = require('@sap/di.code-validation.core');
var fileUtils = coreLibs.fileUtils;
var path = require('path');

"use strict";
var SEVERITY_WARNING = "warning";
var SEVERITY_ERROR = "error";
var CODE_MISSING_ID = "XML_MISSING_STABLE_ID";
var GENERATE_IDS_COMMAND = 'FIORI.XML_GENERATE_ID_CMD';


function IssuesHandler(sFullPath) {
    var oResult = {
        "root": {},
        "issues": []
    };

    var oIssueBuilder = {};
    oIssueBuilder['warning'] = function (oIssue) {
        oResult.root.severity = SEVERITY_ERROR;
        oIssue.severity = SEVERITY_ERROR;
        return oIssue;
    };
    oIssueBuilder['error'] = function (oIssue) {
        oResult.root.severity = SEVERITY_ERROR;
        oIssue.severity = SEVERITY_ERROR;
        return oIssue;

    };
    oIssueBuilder['fatalError'] = function (oIssue) {
        return oIssueBuilder[SEVERITY_ERROR](oIssue);
    };

    return {
        handleError: function (level, msg) {
            /* msg has the following structure
             [xmldom warning]\tunclosed xml attribute\n@#[line:2,col:5]
             */

            //regular expression to match the line number from the message
            var matchLine = /\bline:(\d+)/g.exec(msg);
            var _line = (matchLine && matchLine.length > 1) ? matchLine[1] : 0;
            //regular expression to match the column number from the message
            var matchColumn = /\bcol:(\d+)/g.exec(msg);
            var _column = (matchColumn && matchColumn.length) > 1 ? matchColumn[1] : 0;

            //following expression was not working: var matchText = /(\[.*?\]\\t)(.*)(\\n.*\[.*?\])/g.exec(msg);
            //therefore splitting to find start and end to get the msg text
            var startMatchText = /\[.*?\]/.exec(msg);//[xmldom warning]
            var _startText = (startMatchText && startMatchText.length > 0) ? startMatchText[0] : "";
            var endMatchText = /@#\[.*?\]/g.exec(msg);//@#[line:2,col:5]
            var _endText = (endMatchText && endMatchText.length > 0) ? endMatchText[0] : "";

            var _text = msg.replace(_startText, "").replace(_endText, "").trim();
            _text = _text.replace(new RegExp(/!!/, 'g'),""); //xmldom messages contains !!, which are not user friendly. removing it.

            var oIssue = {
                category: "Syntax Error",
                checker: "",
                helpUrl: "",
                line: parseInt(_line),
                column: parseInt(_column),
                message: _text,
                source: "",
                path: sFullPath
            };

            if (typeof oIssueBuilder[level] !== 'function') {
                console.log("xml validation: wrong severity value sent by dom parser: " + level);
                oResult.issues.push(oIssueBuilder[SEVERITY_ERROR](oIssue));
            } else {
                oResult.issues.push(oIssueBuilder[level](oIssue));
            }
        },

        getIssues: function () {
            return oResult;
        }
    };
}

function _validateFiles(validationMetadata, fileResources) {
    var report = {issues: []};
    fioriAnalysis.init(validationMetadata);
    fileResources.forEach(function (fileResource) {
        //configurations for the parser error handlers
        var issuesHandler = new IssuesHandler(fileResource.getPath());
        var parser = new domParser({locator:{}, errorHandler:issuesHandler.handleError, domBuilder: new domHandler()});
        //Start to parse - the configured handler will be called while parsing
        var document = parser.parseFromString(fileResource.getText());
        var syntaxIssues = issuesHandler.getIssues();
        report.issues = report.issues.concat(syntaxIssues.issues);

        if (syntaxIssues.issues.length <= 0) {
            //run fiori rules and ui5 semantic checks
            try {
                var fioriIssues = fioriAnalysis.runAnalysisOnParsedDocument(document, fileResource);
                report.issues = report.issues.concat(fioriIssues.issues);
            } catch (e) {
                console.log("fiori analysis failed : " + e.message);
            }
        }
    });
    return report;
}
function _getViewFilesForProject(validationMetadata, managedResources){
	managedResources = managedResources || [];
	var managedPaths = managedResources.map(resource => resource.getPath());
    var fileResources = [];
        var files = fileUtils.listFilteredFilesSync(validationMetadata.getRootPath(), {
            extensions: [".xml"],
            ignoredPaths: [
                path.join(validationMetadata.getRootPath(), 'node_modules'),
				path.join(validationMetadata.getRootPath(), 'dist')
            ]
        }) || [];
        files.forEach(function (filePath) {
			if (filePath.endsWith(".xml") || managedPaths.indexOf(filePath) !== -1) {
				var fileResource = new coreLibs.fileResource(validationMetadata.getRootPath(), filePath);
				fileResources.push(fileResource);
			}
        });
        return fileResources.concat(managedResources);
}

module.exports = {
    validateFileForFioriChecks: function validateFileForFioriChecks(xmlParsedDoc, fileResource, validationMetadata) {
        var report = {issues: []};
        if (!validationMetadata) {
            validationMetadata = new coreLibs.validationMetadata(process.cwd());
        }
        fioriAnalysis.setAsFiori(fileResource, validationMetadata);
        //run fiori rules and ui5 semantic checks
        try {
            var fioriIssues = fioriAnalysis.runAnalysisOnParsedDocument(xmlParsedDoc, fileResource);
            if (fioriIssues && fioriIssues.issues.length > 0) {
                report.issues = report.issues.concat(fioriIssues.issues);
            }
        }
        catch (e) {
            throw e;
        }

        return report;
    },

    validateFiles: function validateFiles(validationMetadata, fileResources) {
        if (!validationMetadata) {
            validationMetadata = new coreLibs.validationMetadata(process.cwd());
        }
        if (!fileResources) {
            fileResources = _getViewFilesForProject(validationMetadata);
        }
        return _validateFiles(validationMetadata, fileResources);
    },

    getCodeActionCommands: function (issueCode) {
        var aCommands = [];
        if (issueCode === CODE_MISSING_ID) {
			aCommands.push({
                title: utils.getText('XML_GENERATE_ID_CMD_TITLE', []),
                command: GENERATE_IDS_COMMAND
            });
        }
        return aCommands;
    },

    executeCommand: function (commandId, validationMetadata, managedResources){
        if (commandId === GENERATE_IDS_COMMAND){
            let fileResources = _getViewFilesForProject(validationMetadata, managedResources);
            let edits = fioriAnalysis.generateStableIds(validationMetadata, fileResources);
            return {changes: edits};
        }
    },

	/**
     * return list of supported command ids to be executed on executeCommand
	 */
	getSupportedCommands: function () {
        return [GENERATE_IDS_COMMAND];
	},

	/**
     * config file requires full project scan on change, manifest.json change can affect the stable ids validation
	 * @param {string} fsPath
	 * @return {boolean}
	 */
	isConfigFile: function (fsPath) {
		return fsPath.split('/').pop() === "manifest.json";
	}
};
