var jsonLSP = require('vscode-json-languageservice');
var getSchema = require('./schemaUtils.js');
var neoAppValidatorUtil = require('./neoApp/neoAppValidator.js');
var _ = require('lodash');
var fs = require('fs');
var Q = require('q');
var path = require('path');

var vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
var fioriSchemaProvider = require("./manifest/utils/fioriSchemaProvider.js");
var JSONValidator = jsonLSP.getLanguageService({
    schemaRequestService: null,
    workspaceContext: "./",
    contributions: []
});


var SEVERITY = {
    1: "error",
    2: "warning",
    3: "information",
    4: "hint"
};

function validateFiles(validationMetadata, fileResources) {
    var aPromises = [];

    var oSettings = getSettings(validationMetadata);
    JSONValidator.configure(oSettings.json);

    fileResources.forEach(function (fileResource) {
        aPromises.push(singleFileValidationHandler(fileResource));
    });

    return Q.all(aPromises).then(function (aProblems) {
        return {issues: _.flatten(aProblems)};
    })
}

function singleFileValidationHandler(fileResource) {
    var jsonDocument = JSONValidator.parseJSONDocument(fileResource);
    var fileContent = fs.readFileSync(fileResource.filePath).toString();
    var textDocument = vscode_languageserver_protocol_1.TextDocument.create(fileResource.filePath, "json", 0, fileContent);
    var documentSettings = textDocument.languageId === 'jsonc' ? {
        comments: 'ignore',
        trailingCommas: 'ignore'
    } : {comments: 'error', trailingCommas: 'error'};

    return JSONValidator.doValidation(textDocument, jsonDocument, documentSettings).then(function (diagnostics) {
        return resultHandler(diagnostics, fileResource);
    });
}

function resultHandler(diagnostics, fileResource) {
    var issues = [];
    diagnostics.forEach(function (diagnostic) {
        var issue = {
            range: diagnostic.range,
            checker: "",
            category: "Syntax Error",
            column: diagnostic.range.start.character + 1,
            line: diagnostic.range.start.line + 1,
            message: diagnostic.message,
            path: fileResource.filePath,
            ruleId: "",
            severity: SEVERITY[diagnostic.severity]
        };
        issues.push(issue);
    });
    return issues;
}

function getManifestURL(curPath) {
    var files = fs.readdirSync(curPath);
    for (var i = 0; i < files.length; i++) {
        var file = files[i];
        if (file === 'manifest.json') {
            return path.join(curPath, "manifest.json");
        }
        var newPath = path.join(curPath, file);
        if (file != 'dist' && file != 'node_modules' && fs.lstatSync(newPath).isDirectory()) {
            var foundPath = getManifestURL(newPath);
            if (foundPath) {
                return foundPath;
            }
        }
    }
};

function getProjectJson(validationMetadata) {
    var _projectJsonPath = path.join(validationMetadata.getRootPath(), ".che", "project.json");

    // read file
    var _projectJsonContent;
    try {
        if (fs.existsSync(_projectJsonPath)) {
            _projectJsonContent = fs.readFileSync(_projectJsonPath, 'utf8');
        }
    } catch (err) {
        console.log("failed to read project.json file")
    }
    if (_projectJsonContent) {
        try {
            return JSON.parse(_projectJsonContent);
        } catch (err) {
            console.log("invalid json in project.json")
        }
    }
    return {};
}

function getProjectSettings(_oProjectJson) {
    if (_oProjectJson.attributes) {
        var _commonSettings = _oProjectJson.attributes["sap.watt.common.setting"];
        if (_commonSettings && _commonSettings.length > 0) {
            var _sProjectSettings = _commonSettings[0];
            if (_sProjectSettings) {
                try {
                    return JSON.parse(_sProjectSettings);
                } catch (err) {
                    console.log("invalid json of sap.watt.common.setting attribute in project.json")
                }
            }
        }
    }
    return {};
}

function getProjectTypes(projSetting) {
    if (projSetting && projSetting.projectType && projSetting.projectType.length > 0) {
        return projSetting.projectType;
    }
    return [];
}

function getSettings(validationMetadata) {
    var oNeoAppSchema = neoAppValidatorUtil.getSchema();
    var oManifestFileURL = getManifestURL(validationMetadata.projPath);
    var envType=undefined;
    var projJson = getProjectJson(validationMetadata);
    var sBaseType = projJson.type ? projJson.type : "";
    if (oManifestFileURL) {
        var parsedManifest = getSchema._getRemoteJsonResource(oManifestFileURL);
        var oManifestSchema = fioriSchemaProvider.getSchema(parsedManifest, envType, isModule(sBaseType));
    }

    var JSONSchemaSettings = [];
    JSONSchemaSettings.push({
        fileMatch: ["neo-app.json"],
        schema: oNeoAppSchema,
        uri: "file://neo-app.json"
    });
    var manifestIgnoredProjectType = "com.watt.uitools.plugin.reuselibrary";
    var projSetting = getProjectSettings(projJson);
    var projectTypesFromSettings = getProjectTypes(projSetting);

    if (projectTypesFromSettings.indexOf(manifestIgnoredProjectType) < 0) {
        JSONSchemaSettings.push({
            fileMatch: ["manifest.json"],
            schema: oManifestSchema,
            uri: "file://manifest.json"
        });
    }
    var oSettings = {
        json: {
            schemas: JSONSchemaSettings,
            validate: true
        }
    };
    return oSettings;
}

function isModule(sBaseType) {
    return sBaseType === "com.sap.hcp.html5" ? true : false;
}

module.exports = {
    validateFiles: validateFiles
};
