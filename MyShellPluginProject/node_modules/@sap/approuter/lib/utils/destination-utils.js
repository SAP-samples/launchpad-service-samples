'use strict';

var _ = require('lodash');
var loggingUtils = require('./logger');
var logger = loggingUtils.getLogger('/Destination service');
var xsenv = require('@sap/xsenv');
var request = require('request');
var tokenUtils = require ('./token-utils');

exports.adjustDestinationProperties = adjustDestinationProperties;
exports.normalizeDestinationProperties = normalizeDestinationProperties;
exports.getDestinationServiceCredentials = getDestinationServiceCredentials;
exports.findDestination = findDestination;
exports.getDestinationsByTenant = getDestinationsByTenant;

function getDestinationsByTenant(tenant, cb){
  getDestinationsByTenantReqOptions(tenant, function(error, requestOptions){
    if (error){
      return cb(error);
    }
    request.get(requestOptions, function onResponse(err, res) {
      if (err || !res || !res.statusCode) {
        if (err){
          logger.error('Destination error: ' + err);
        }
        return cb('Error while retrieving destinations for tenant ' + tenant);
      }
      if (res.statusCode !== 200 || !res.body) {
        var errorMessage = 'Error while retrieving destinations for tenant ' + tenant + ' from destination service. HTTP status code: ' + res.statusCode;
        logger.error(errorMessage);
        return cb(errorMessage);
      }
      try {
        var destinationLookUpResult = JSON.parse(res.body);
      } catch (err) {
        return cb(err);
      }
      cb(null, destinationLookUpResult);
    });
  });
}

function adjustDestinationProperties(destinations) {
  destinations.forEach(function (destination) {
    if (destination.proxyType === 'OnPremise') {
      try {
        var credentials = xsenv.serviceCredentials({tag: 'connectivity'});
        destination['proxyHost'] = credentials.onpremise_proxy_host;
        destination['proxyPort'] = credentials.onpremise_proxy_port;
      } catch (error) {
        throw 'Destination \"' + destination.name +
        '\" with  ProxyType \"OnPremise\" but connectivity service is not bound.';
      }
    }
    _.defaults(destination, {
      timeout: 30000
    });
  });
}

function normalizeDestinationProperties(destinations) {
  if (!destinations) {
    return;
  }
  if (!Array.isArray(destinations)){
    throw new Error('destinations type invalid, array is expected');
  }
  destinations.forEach(function (destination, i, destinations) {
    if (destinations[i].Authentication){ // if it destination from destinations service
      destinations[i] = normalizeDestination (destination);
      destinations[i].forwardAuthToken = destinations[i].forwardAuthToken === 'true' || destinations[i].forwardAuthToken === true;
      destinations[i].preserveHostHeader = destinations[i].preserveHostHeader === 'true' || destinations[i].preserveHostHeader === true;
      destinations[i].dynamicDestination = destinations[i].dynamicDestination === 'true' || destinations[i].dynamicDestination === true;
      if (destinations[i].hasOwnProperty('setXForwardedHeaders')) {
        destinations[i].setXForwardedHeaders = destinations[i].setXForwardedHeaders === 'true' || destinations[i].setXForwardedHeaders === true;
      }
      if (destinations[i].timeout && !isNaN(destinations[i].timeout)) {
        destinations[i].timeout = _.toSafeInteger(destinations[i].timeout);
      }
    }
  });
}

function getDestinationsByTenantReqOptions (tenant, cb) {
  var credentials = getDestinationServiceCredentials();
  if (!credentials) {
    return cb ('Destination service is not bound');
  }
  var headers = {'accept': 'application/json;charset=utf-8'};
  tokenUtils.getClientCredentialsTokenByTenant(tenant, credentials, function(err, token){
    if (err){
      return cb(err);
    }
    headers.Authorization = 'Bearer ' + token.accessToken;
    return cb (null, {
      url: credentials.uri + '/destination-configuration/v1/subaccountDestinations',
      headers: headers
    });
  });
}

function getFindDestinationReqOptions (destinationName, token, options, cb) {
  var credentials = getDestinationServiceCredentials ();
  var headers = {'accept': 'application/json;charset=utf-8'};
  if (!credentials) {
    return cb ('Destination service is not bound');
  }

  var auth;
  if (token){
    auth = token;
  } else if (options && options.app && options.app.services['destination'] && options.app.services['destination'].token){
    auth = options.app.services['destination'].token.accessToken;
  } else {
    return cb('obtain token error');
  }
  headers.Authorization = 'Bearer ' + auth;
  return cb (null, {
    url: credentials.uri + '/destination-configuration/v1/destinations/' + destinationName,
    headers: headers
  });
}

function normalizeDestination (destination){
  if (!destination) {
    return;
  }
  var keys = Object.keys(destination);
  var n = keys.length;
  var newobj = {};
  var key;
  while (n--) {
    key = keys[n];
    if (key === 'URL'){
      newobj[key.toLowerCase()] = destination[key];
    } else
    {
      var value = destination[key];
      key = key.replace('HTML5.', '');
      var newKey = key.substr(0, 1).toLowerCase() + key.substr(1);
      newobj[newKey] = value;
    }
  }
  return newobj;
}

function getDestinationServiceCredentials() {
  var errorOccurred;
  var credentials;
  try {
    credentials = xsenv.serviceCredentials({tag: 'destination'});
  } catch (e) {
    errorOccurred = true;
  }
  if (errorOccurred || !credentials) {
    return null;
  }
  return credentials;
}

// Finds a destination by name on all levels and returns the first match
// Search priority is destination on instance level and after that fallback to the shared destinations on subaccount level.
function findDestination (destinationName, token, options, cb){
  if (!destinationName) {
    return cb('Cannot find destination, destination name is missing');
  }

  if (destinationName.includes('$')){
    return cb('destination contains invalid characters, check xs-app.json route.source attribute to make sure the regex is correct');
  }

  if (destinationName.includes('*')){
    return cb('destination contains invalid characters, make sure the DESTINATION_HOST_PATTERN regex is correct');
  }

  var errorMessage;
  getFindDestinationReqOptions(destinationName, token, options, function(error, requestOptions){
    if (error){
      return cb(error);
    }
    request.get(requestOptions, function onResponse(err, res) {
      if (err || !res || !res.statusCode) {
        if (err){
          logger.error('Destination error: ' + err);
        }
        return cb('Error while retrieving destination ' + destinationName + ' from destination service');
      }
      if (res.statusCode !== 200 || !res.body) {
        errorMessage = 'Error while retrieving destination ' + destinationName + ' from destination service. HTTP status code: ' + res.statusCode;
        logger.error(errorMessage);
        return cb(errorMessage);
      }
      try {
        var destinationLookUpResult = JSON.parse(res.body);
      } catch (err) {
        return cb(err);
      }
      cb(null, destinationLookUpResult);
    });
  });
}