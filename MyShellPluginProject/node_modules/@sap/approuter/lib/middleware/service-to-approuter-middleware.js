'use strict';
var jwtDecode = require('jwt-decode');
var passportUtils = require('../passport/utils');
var xsenv = require('@sap/xsenv');
var xssec = require('@sap/xssec');
var pathUtil = require('../utils/path-util');

module.exports = function (req, res, next) {

  let auth = req.headers && req.headers['x-approuter-authorization'];

  if (!auth){
    return next();
  }
  var tracer = req.loggingContext.getTracer(__filename);
  tracer.info('Incoming request contains x-approuter-authorization header');

  if (req.routerConfig && pathUtil.isPublicPath(req)){
    tracer.warning('Request to public route with source %s contains x-approuter-authorization header ', req.internalUrl.route.source);
  }

  var authArr = auth.split(' ');
  var type = authArr[0];
  var value = authArr[1];
  try {
    var token = value;
    var ownUAACredentials = xsenv.serviceCredentials({tag: 'xsuaa'});
    xssec.createSecurityContext(token, ownUAACredentials, function (err) {
      var error;
      if (err) {
        tracer.info('Token validation failed');
        err.status = 401;
        writeAuditLog(req, token, err, tracer, next);
      } else if (type.toLowerCase() !== 'bearer') {
        tracer.info('x-approuter-authorization header is not a Bearer token');
        error = new Error('x-approuter-authorization header is not a Bearer token');
        error.status = 400;
        writeAuditLog(req, token, error, tracer, next);
      } else {
        var tokenDecoded = jwtDecode(value);
        var tokenContext = {
          accessToken: value,
          expiresIn: Date.now() + 600000,
          scope: tokenDecoded.scope
        };
        var user = passportUtils.getUserProperties(tokenContext);

        req.session = {
          jwtRefreshStarted: true,
          user: user,
          req: req,
          reload: (cb) => { cb(); },
          save: () => {},
          touch: () => {}
        };
        tracer.info('Session created successfully');
        return next();
      }
    });
  } catch (error) {
    tracer.info('service-to-approuter-middleware: failed');
    next (error);
  }

};

function writeAuditLog (req, token, error, tracer, next) {
  var auditlogCredentials;
  try {
    auditlogCredentials = xsenv.serviceCredentials({tag: 'auditlog'});
  } catch (error) {
    auditlogCredentials = null;
  }
  var IP = (auditlogCredentials) ? req.headers['x-forwarded-host'] : '******';
  var authorization = (auditlogCredentials) ? token : '******';
  var sourceOfRoute = req.internalUrl ? req.internalUrl.route.source : req.url;
  var message = error.message + '- Source of route: ' + sourceOfRoute + ', IP: ' + IP + ', x-approuter-authorization: ' + authorization;
  req.app.auditLogger.securityMessage(message)
    .by('Service to Approuter request')
    .log(function (err) {
      if (err) {
        tracer.info('Error occurred when writing to audit log. Error: %s', err.message);
      }
      return next(error);
    });
}