'use strict';
var xsenv = require('@sap/xsenv');
var xssec = require('@sap/xssec');
var destinationUtils = require('../../lib/utils/destination-utils');
var jwtDecode = require('jwt-decode');
var expiresAt = require('../passport/utils').getExpiresAt;
var validators = require('../configuration/validators');

var self = module.exports = {

  retrieveDestination: function (options, cb){
    self.replaceUserToken(options, function(err, userExchangeToken) {
      if (err) {
        return cb(err);
      }
      var tokenDecoded;
      var userExchangeTokenExpiresAt;
      var destinationName = options.destinationName;
      destinationUtils.findDestination(destinationName, userExchangeToken, options, function (err, destinationLookUpResult){
        if (err){
          return cb(err);
        }
        try {
          if (!destinationLookUpResult || !destinationLookUpResult.destinationConfiguration) {
            return cb('Cannot get destination configuration for destination ' + destinationName);
          }
          if (destinationLookUpResult.authTokens && destinationLookUpResult.authTokens[0].hasOwnProperty('error')) {
            return cb(destinationLookUpResult.authTokens[0].error);
          }
          if (destinationLookUpResult.authTokens) {
            var authTokenExpiresIn = destinationLookUpResult.authTokens[0].expires_in;
            destinationLookUpResult.authTokens[0].expireDate = destinationLookUpResult.authTokens[0].expires_in ? expiresAt(authTokenExpiresIn).getTime() : 0;
          }
          var result = {};
          if (userExchangeToken) {
            tokenDecoded = jwtDecode(userExchangeToken);
            userExchangeTokenExpiresAt = expiresAt(tokenDecoded.exp - tokenDecoded.iat).getTime();
            result.userExchangeToken = {token: userExchangeToken, expireDate: userExchangeTokenExpiresAt};
          }
          var destinations = [destinationLookUpResult.destinationConfiguration];
          destinationUtils.normalizeDestinationProperties(destinations);
          validators.validateDestinations(destinations);
          destinationUtils.adjustDestinationProperties(destinations);
          result.destination = destinations[0];
          if (options.dynamicDestination && !result.destination.dynamicDestination){
            return cb('Destination ' + destinationName + ' is not defined as a dynamic destination in destination service, configure additional property HTML5.DynamicDestination true');
          }
          result.authToken = destinationLookUpResult.authTokens ? destinationLookUpResult.authTokens[0] : null;
          return cb(null, result);
        } catch (error){
          return cb(error);
        }
      });
    });
  },

  isDestinationServiceFlow: function (internalUrl){
    if (!internalUrl || !internalUrl.route || !internalUrl.route.destination || !internalUrl.destination ||
        internalUrl.destination.url  !== 'DESTINATION_URL_PLACEHOLDER'){
      return false;
    }
    return true;
  },

  replaceUserToken: function (options, cb){
    var session = options.session;
    if (!session || !session.user){
      return cb(null);
    }
    shouldRequestUserExchangeToken (session, function(err, askForToken){
      if (err) {
        return cb(err);
      }
      if (!askForToken) {
        var userExchangeToken = session.user.destinationUserExchangeToken.token;
        return cb(null, userExchangeToken);
      }
      var ownUAACredentials = xsenv.serviceCredentials({label: 'xsuaa'});
      var externalServiceCredentials = destinationUtils.getDestinationServiceCredentials();
      var jwt = options.jwt;
      if (!jwt){
        jwt = options.session.user.token.accessToken;
      }
      getUserExchangeToken(jwt, ownUAACredentials, externalServiceCredentials, cb);
    });
  }
};

function getUserExchangeToken(loginToken, ownUAACredentials, externalServiceCredentials, cb){
  try {
    xssec.createSecurityContext(loginToken, ownUAACredentials, function (error, secContext) {
      if (error) {
        cb(error, null);
      } else {
        secContext.requestToken(Object.assign({}, externalServiceCredentials, {
          url: externalServiceCredentials.url.replace(
              externalServiceCredentials.identityzone,
              secContext.subdomain
          )
        }), xssec.constants.TYPE_USER_TOKEN, null, function (error, userExchangeToken) {
          if (error) {
            cb(error, null);
          } else {
            cb(null, userExchangeToken);
          }
        });
      }
    });
  } catch (err) {
    cb(err);
  }
}

function shouldRequestUserExchangeToken(session, cb){
  var destinationTokensCache = session.user.destinationUserExchangeToken;

  // check the expiration of destinationUserExchangeToken
  if (!destinationTokensCache || (!destinationTokensCache.token || destinationTokensCache.expireDate < Date.now())) {
    return cb (null, true);
  }
  return cb (null, false);
}
