'use strict';

const util = require('util');

const debug = require('debug');
const debugTrace = debug('xssec:validators');
const debugError = debug('xssec:validators');

const jwt = require('jsonwebtoken');

const DOT = ".";

const ValidationResults = new function () {
    function Result(suc, desc) {
        var state = suc;
        var description = desc || "";

        this.isValid = function () {
            return suc === true;
        }

        this.isErroneous = function () {
            return suc === false;
        }

        this.getErrorDescription = function () {
            return description;
        }
    };

    this.createValid = function () {
        return new Result(true);
    }

    this.createInvalid = function (description) {
        return new Result(false, description)
    }
};

function JwtAudienceValidator(clientId) {
    var clientIds = [];
    var foreignMode = false;

    this.configureTrustedClientId = function (clientId) {
        if (clientId) {
            clientIds.push(clientId);
        }

        debugTrace("configured JwtAudienceValidator with clientId", clientId);
        return this;
    }

    this.validateToken = function (audiencesFromToken) {
        foreignMode = false;
        var allowedAudiences = getAllowedAudiencesFromToken(audiencesFromToken);
        if (validateAudienceOfXsuaaBrokerClone(allowedAudiences) === true || validateDefault(allowedAudiences) === true) {
            return ValidationResults.createValid();
        }

        return ValidationResults.createInvalid("Jwt token with audience: " + util.inspect(allowedAudiences) + " is not issued for these clientIds: " + util.inspect(clientIds) + ".");
    }

    this.isForeignMode = function() {
        return foreignMode;
    }

    //iterate over all configured clientIds and return true of the cb returns true
    function forEachClientId(cb) {
        for (var i = 0; i < clientIds.length; ++i) {
            if (cb(clientIds[i]) === true) {
                return true;
            }
        }

        return null;
    }

    function validateDefault(allowedAudiences) {
        return forEachClientId(function (configuredClientId) {
            if (allowedAudiences.includes(configuredClientId)) {
                return true;
            }
        });
    }

    function validateAudienceOfXsuaaBrokerClone(allowedAudiences) {
        var ret = forEachClientId(function (configuredClientId) {
            if (configuredClientId.includes("!b")) { //isBrokerClientId
                for (var i = 0; i < allowedAudiences.length; ++i) {
                    var audience = allowedAudiences[i];
                    if (audience.endsWith("|" + configuredClientId)) {
                        return true;
                    }
                }
            }
        });

        if(ret === null) {
            foreignMode = true;
        }
        return ret;
    }

    function getAllowedAudiencesFromToken(aud) {
        var audiences = [];
        var tokenAudiences = aud || [];

        for (var i = 0; i < tokenAudiences.length; ++i) {
            var audience = tokenAudiences[i];
            if (audience.indexOf(DOT) > -1) {
                // CF UAA derives the audiences from the scopes.
                // In case the scopes contains namespaces, these needs to be removed.
                var aud = audience.substring(0, audience.indexOf(DOT)).trim();
                if (aud && aud.length > 0) {
                    audiences.push(aud);
                }
            } else {
                audiences.push(audience);
            }
        }
        return audiences;
    }

    //allow an empty constructor
    if (clientId) {
        this.configureTrustedClientId(clientId);
    }
};

function JwtTokenValidator(verificationKey, config) {
    var foreignMode = false;

    this.isForeignMode = function() {
        return foreignMode;
    }

    //prepare JWT validators
    this.validateToken = function (accessToken, cb) {
        function returnError(code, errorString) {
            debugError('\n' + errorString);
            var error = new Error(errorString);
            error.statuscode = code;
            return cb(error);
        }

        jwt.verify(accessToken,
            verificationKey.getCallback(),
            {
                algorithms: ['RS256'] //we currently only allow RS256
            },
            function (err, decodedToken) {
                if (err) {
                    debugError(err.message);
                    debugError(err.stack);
                    err.statuscode = accessToken ? 403 : 401;
                    return cb(err);
                }

                if (!decodedToken.cid) {
                    return returnError(400, 'Client Id not contained in access token. Giving up!');
                }

                if (!decodedToken.zid) {
                    return returnError(400, 'Identity Zone not contained in access token. Giving up!');
                }

                var audienceValidator = new JwtAudienceValidator(config.clientid);
                if (config.xsappname) {
                    audienceValidator.configureTrustedClientId(config.xsappname);
                }

                var valid_result = audienceValidator.validateToken(decodedToken.aud);
                if (!valid_result.isValid()) {
                    return returnError(403, valid_result.getErrorDescription());
                }

                if(config.clientid !== decodedToken.cid) {
                    foreignMode = audienceValidator.isForeignMode();
                }

                cb(null, decodedToken);
            });
    };
};

module.exports = {
    JwtAudienceValidator: JwtAudienceValidator,
    JwtTokenValidator: JwtTokenValidator
};