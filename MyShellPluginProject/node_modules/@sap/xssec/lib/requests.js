'use strict';

var constants = require('./constants');
var request = require('request');
var url = require('url');

// use environment variable DEBUG with value 'xssec:*' for trace/error messages
var debug = require('debug');
var debugTrace = debug('xssec:requests');
var debugError = debug('xssec:requests');

debugError.log = console.error.bind(console);
debugTrace.log = console.log.bind(console);

module.exports.requestUserToken = function(securityContext, serviceCredentials, additionalAttributes, scopes, adaptSubdomain, cb) {
    // input validation
    if (!serviceCredentials) {
        var error = new Error('Parameter serviceCredentials is missing but mandatory.');
        return cb(error, null);
    }
    if (!serviceCredentials.clientid || !serviceCredentials.clientsecret) {
        var error = new Error('Invalid service credentials: Missing clientid/clientsecret.');
        return cb(error, null);
    }
    if (!serviceCredentials.url) {
        var error = new Error('Invalid service credentials: Missing url.');
        return cb(error, null);
    }
    // adapt subdomain in service url, if necessary
    var urlWithCorrectSubdomain = serviceCredentials.url;
    if (adaptSubdomain === true) {
        var tokenSubdomain = securityContext.getSubdomain();
        var tokenRequestSubdomain = null;
        var uaaUrl = url.parse(serviceCredentials.url);
        if (uaaUrl.hostname.indexOf('.') === -1) {
            tokenRequestSubdomain = null;
        } else {
            tokenRequestSubdomain = uaaUrl.hostname.substring(0, uaaUrl.hostname.indexOf('.'));
        }
        if (tokenSubdomain !== null && tokenRequestSubdomain != null && tokenSubdomain !== tokenRequestSubdomain) {
            urlWithCorrectSubdomain = uaaUrl.protocol + "//" + tokenSubdomain + uaaUrl.host.substring(uaaUrl.host.indexOf('.'), uaaUrl.host.size);
        }
    }
    // jwt bearer flow
    var options = {
        url : urlWithCorrectSubdomain + '/oauth/token?grant_type=' + encodeURIComponent('urn:ietf:params:oauth:grant-type:jwt-bearer') +
                '&response_type=token&client_id=' + serviceCredentials.clientid + '&assertion=' + securityContext.getAppToken(),
        headers: { Accept: 'application/json' },
        auth: {
            user: serviceCredentials.clientid,
            pass: serviceCredentials.clientsecret
        },
        timeout: 2000
    };
    if (scopes !== null) {
        options.url = options.url + "&scope=" + scopes;
    }
    if (additionalAttributes !== null) {
        var authorities = { "az_attr" : additionalAttributes };
        options.url = options.url + "&authorities=" + encodeURIComponent(JSON.stringify(authorities));
    }
    request.post(
        options,
        function(error, response, body) {
            if (error) {
                if (error.code === 'ETIMEDOUT' && error.connect === true) {
                    debugError('requestToken: HTTP connection timeout.');
                }
                debugError(error.message);
                debugError(error.stack);
                return cb(error, null);
            }
            if (response.statusCode === 401) {
                debugTrace('requestToken: Call to /oauth/token was not successful (grant_type: urn:ietf:params:oauth:grant-type:jwt-bearer). Bearer token invalid, requesting client does not have the grant_type or no scopes were granted.');
                return cb(new Error('Call to /oauth/token was not successful (grant_type: urn:ietf:params:oauth:grant-type:jwt-bearer). Bearer token invalid, requesting client does not have the grant_type or no scopes were granted.'), null);
            }
            if (response.statusCode !== 200) {
                debugTrace('requestToken: Call to /oauth/token was not successful (grant_type: urn:ietf:params:oauth:grant-type:jwt-bearer). HTTP status code: ' + response.statusCode);
                return cb(new Error('Call to /oauth/token was not successful (grant_type: urn:ietf:params:oauth:grant-type:jwt-bearer). HTTP status code: ' + response.statusCode), null);
            }
            var json = null;
            try {
                json = JSON.parse(body);
            } catch (e) {
                return cb(e, null);
            }
            return cb(null, json.access_token)
            // refresh token flow
        }
    );
}

module.exports.requestClientCredentialsToken = function(securityContext, serviceCredentials, additionalAttributes, cb) {
    // input validation
    if (!serviceCredentials) {
        var error = new Error('Parameter serviceCredentials is missing but mandatory.');
        return cb(error, null);
    }
    if (!serviceCredentials.clientid || !serviceCredentials.clientsecret) {
        var error = new Error('Invalid service credentials: Missing clientid/clientsecret.');
        return cb(error, null);
    }
    if (!serviceCredentials.url) {
        var error = new Error('Invalid service credentials: Missing url.');
        return cb(error, null);
    }
    // adapt subdomain in service url, if necessary
    var urlWithCorrectSubdomain = serviceCredentials.url;
    var tokenSubdomain = securityContext.getSubdomain();
    var tokenRequestSubdomain = null;
    var uaaUrl = url.parse(serviceCredentials.url);
    if (uaaUrl.hostname.indexOf('.') === -1) {
        tokenRequestSubdomain = null;
    } else {
        tokenRequestSubdomain = uaaUrl.hostname.substring(0, uaaUrl.hostname.indexOf('.'));
    }
    if (tokenSubdomain !== null && tokenRequestSubdomain != null && tokenSubdomain !== tokenRequestSubdomain) {
        urlWithCorrectSubdomain = uaaUrl.protocol + "//" + tokenSubdomain + uaaUrl.host.substring(uaaUrl.host.indexOf('.'), uaaUrl.host.size);
    }
    // client credentials flow
    var options = {
        url : urlWithCorrectSubdomain + '/oauth/token?grant_type=client_credentials&response_type=token',
        headers: { 'Accept' : 'application/json', 'Content-Type' : 'application/x-www-form-urlencoded' },
        auth: {
            user: serviceCredentials.clientid,
            pass: serviceCredentials.clientsecret
        },
        timeout: 2000
    };
    if (additionalAttributes !== null) {
        var authorities = { "az_attr" : additionalAttributes };
        options.url = options.url + "&authorities=" + encodeURIComponent(JSON.stringify(authorities));
    }
    request.post(
        options,
        function(error, response, body) {
            if (error) {
                if (error.code === 'ETIMEDOUT' && error.connect === true) {
                    debugError('requestToken: HTTP connection timeout.');
                }
                debugError(error.message);
                debugError(error.stack);
                return cb(error, null);
            }
            if (response.statusCode === 401) {
                debugTrace(body);
                debugTrace('requestToken: Call to /oauth/token was not successful (grant_type: client_credentials). Client credentials invalid.');
                return cb(new Error('Call to /oauth/token was not successful (grant_type: client_credentials). Client credentials invalid.'), null);
            }
            if (response.statusCode !== 200) {
                debugTrace('requestToken: Call to /oauth/token was not successful (grant_type: client_credentials). HTTP status code: ' + response.statusCode);
                return cb(new Error('Call to /oauth/token was not successful (grant_type: client_credentials). HTTP status code ' + response.statusCode), null);
            }
            var json = null;
            try {
                json = JSON.parse(body);
            } catch (e) {
                return cb(e, null);
            }
            return cb(null, json.access_token);
        }
    );
};
