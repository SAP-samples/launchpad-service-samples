'use strict';
const keycache = require('./keycache');

const constants = require('./constants');
const request = require('request');
const url = require('url');

var debug = require('debug');
var debugTrace = debug('xssec:verificationkey');

// Note: the keycache is initialized currently with the default size defined in constants
//       Consider making this configurable for the application, e.g. via xssecurity.json
//       or (probably worse) via environment variables.
//       Similarly, the keycache uses the default expiration time for cache entries as 
//       defined in constants. Also here, consider making this configurable. 
const keyCache = new keycache.KeyCache(constants.KEYCACHE_DEFAULT_CACHE_SIZE, constants.KEYCACHE_DEFAULT_CACHE_ENTRY_EXPIRATION_TIME_IN_MINUTES);

function VerificationKey(config) {
    this.getCallback = function() {
        return this.loadKey.bind(this);
    }

    function cleanUp(pem) {
        //the old ccl based jwt verification library was able to read malformed PEM formatted input.
        //but with the jsonwebtoken module we need to clean up some PEM errors before using it...
        if(pem.indexOf("-----BEGIN PUBLIC KEY-----\n") === -1) {
            pem = pem.replace("-----BEGIN PUBLIC KEY-----", "-----BEGIN PUBLIC KEY-----\n");
        }
        if(pem.indexOf("\n-----END PUBLIC KEY-----") === -1) {
            pem = pem.replace("-----END PUBLIC KEY-----", "\n-----END PUBLIC KEY-----");
        }
        return pem;
    }

    function validateJku(jkuUrl, uaaDomain) {
        if (!uaaDomain) {
            return 'Service is not properly configured in \'VCAP_SERVICES\', attribute \'uaadomain\' is missing. Use legacy-token-key.';
        }

        var tokenKeyUrl = url.parse(jkuUrl);
        if (tokenKeyUrl.hostname.substring(tokenKeyUrl.hostname.indexOf(uaaDomain), tokenKeyUrl.hostname.length) !== uaaDomain) {
            return 'JKU of the JWT token (' + jkuUrl + ') does not match with the uaa domain (' + uaaDomain + '). Use legacy-token-key.';
        }
    }

    this.loadKey = function(accessToken, cb) {
        if (!accessToken.kid || accessToken.kid == 'legacy-token-key' || !accessToken.jku) {
            return cb(null, cleanUp(config.verificationkey));
        }

        var errorString = validateJku(accessToken.jku, config.uaadomain);

        if(errorString) {
            debugTrace('\n' + errorString);
            return cb(null, cleanUp(config.verificationkey));
        }

        //try to get a key from KeyCache 
        keyCache.getKey(accessToken.jku, accessToken.kid, function(err, key) {
            if (err) {
                debugTrace('\n', err);
                return cb(null, cleanUp(config.verificationkey));
            } else {
                return cb(null, cleanUp(key));
            }
        });
    }
};

module.exports = VerificationKey;
