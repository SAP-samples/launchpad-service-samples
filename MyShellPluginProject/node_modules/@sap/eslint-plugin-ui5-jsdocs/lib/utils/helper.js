"use strict";

const _ = require("lodash");
const parser = require("comment-parser");

const composeParamString = (sParamType, sParamName, sDescription) => {
  return `* @param {typeof ${sParamType}} ${sParamName} ${sDescription||""}`;
};

let _createJsDocParam = (oModuleArgument) => {
  return composeParamString(
    createJsDocParamType(_.get(oModuleArgument, "modulePath")),
    _.get(oModuleArgument, "argName"), 
    _.get(oModuleArgument, "paramDescription")
  )
};

let createJsDocParam = (oModuleArgument) => {
  return " " + _createJsDocParam(oModuleArgument);
};

let createJsDocParamWithNewLine = (oModuleArgument) => {
  return _createJsDocParam(oModuleArgument) + "\n ";
};

let createJsDocParamType = sModulePath => {
  return _.join(_.split(sModulePath, "/"), ".");
};

let isRelevantModulePath = sModulePath => {
  return sModulePath && sModulePath.match(/^\s*sap\/.*/i); 
};

let getModuleArgumentsPairsToCheck = (aModules, aArguments) => {
  const size = Math.min(_.size(aModules), _.size(aArguments));
  const aElementAndParams = [];
  _.forEach(_.take(aModules, size), (oElement, nIndex) => {
    const sModulePath = _.get(oElement, "value");
    if (isRelevantModulePath(sModulePath)) {
      aElementAndParams.push({
        moduleNode: oElement,
        argName: _.get(aArguments, "[" + nIndex + "].name"),
        modulePath: sModulePath
      });
    }
  });

  return aElementAndParams;
};

module.exports = {
  getJsDocParamTags: oJsDocNode => {
    let aJsDocData = parser("/**\n" + _.get(oJsDocNode, "value", "") + "\n*/", 
    {
      parsers: [
        parser.PARSERS.parse_tag,
        parser.PARSERS.parse_type,
        parser.PARSERS.parse_name,
        parser.PARSERS.parse_description
      ]
    });
    return _.filter(_.get(aJsDocData, ["0", "tags"], []), ["tag", "param"]);
  },

  createJsDocParamType: createJsDocParamType,

  createJsDocParam: createJsDocParam,

  createJsDocParamWithNewLine: createJsDocParamWithNewLine,

  executeOnSapUiDefine: fRuleCallback => {
    return {
      create(context) {
        return {
          "CallExpression > MemberExpression[property.name='define'] > MemberExpression[property.name='ui'] > Identifier[name='sap']": node => {
            let oSapUiDefineCallExpressionNode = _.get(node, ["parent", "parent", "parent"]);
            let oFirstArg = _.get(oSapUiDefineCallExpressionNode, "arguments[0]");
            let oSecondArg = _.get(oSapUiDefineCallExpressionNode, "arguments[1]");
            if (_.get(oFirstArg, "type") === "ArrayExpression" && _.get(oSecondArg, "type") === "FunctionExpression") {
              let aElements = _.get(oFirstArg, "elements", []);
              let aParams = _.get(oSecondArg, "params", []);
              if (_.isEmpty(aElements) || _.isEmpty(aParams)) {
                return;
              }

              const oJsDocComment = context.getSourceCode().getJSDocComment(oSecondArg);
              const aModuleArgumentsToCheck = getModuleArgumentsPairsToCheck(aElements, aParams);
              fRuleCallback.call(this, context, oJsDocComment, aModuleArgumentsToCheck, oFirstArg, oSecondArg);
            }
          }
        };
      }
    };
  }
};