var chai = require('chai');
chai.use(require('chai-string'));
var expect = require('chai').expect;
var sinon = require('sinon');
var path = require('path');

var validation = require("../src/lib/validation.js");
var dummyJsValidator1 = require("./mock/dummyValidators/dummyJsValidator1.js");
var dummyJsValidator2 = require("./mock/dummyValidators/dummyJsValidator2.js");
var ValidationConfig = require("../src/lib/validationConfig");

describe('validation execution of configured validators', function () {

    var sandbox;
    beforeEach(function () {
        sandbox = sinon.sandbox.create();
    });

    it('execution with empty validators', function (done) {
        var config = new ValidationConfig();
        var issues = validation.executeForProject(path.join(__dirname, "mock", "dummyProj"), "dummyProj", config, function (result) {
            expect(result).to.be.object;
            expect(Object.keys(result)).to.have.length(0);
            done();
        });
    });

    it('issues file path without pathPrefix are relative to project', function (done) {
        var config = new ValidationConfig({
            validators: {
                "dummyJsValidator1": {
                    extensions: [".js", ".xsjs"]
                }
            }
        });
        sandbox.stub(validation, "__loadValidators").returns({
            'dummyJsValidator1': dummyJsValidator1
        });
        var projectName = "dummyProj";
        var pathPrefix = undefined;
        var issues = validation.executeForProject(path.join(__dirname, "mock", projectName), pathPrefix, config, function (result) {
            console.log(result);
            var fileKey = Object.keys(result["dummyJsValidator1"]["issues"])[0];
            expect(fileKey).to.not.startWith(projectName);
            expect(path.join(__dirname, "mock", projectName, fileKey)).to.startWith(path.join(__dirname, "mock", projectName));//check file is relative to workspace of project
            expect(fileKey).to.endWith(".js");
            done()
        });
    });

    it('issues file path with project pathPrefix are relative to workspace', function (done) {
        var config = new ValidationConfig({
            validators: {
                "dummyJsValidator1": {
                    extensions: [".js", ".xsjs"]
                }
            }
        });
        sandbox.stub(validation, "__loadValidators").returns({
            'dummyJsValidator1': dummyJsValidator1
        });
        var projectName = "dummyProj";
        var pathPrefix = path.sep + projectName;
        var issues = validation.executeForProject(path.join(__dirname, "mock", projectName), {pathPrefix:pathPrefix}, config, function (result) {
            console.log(result);
            var fileKey = Object.keys(result["dummyJsValidator1"]["issues"])[0];
            expect(fileKey).to.startWith(pathPrefix);
            expect(path.join(__dirname, "mock", fileKey)).to.startWith(path.join(__dirname, "mock", projectName));//check file is relative to workspace of project
            expect(fileKey).to.endWith(".js");
            done()
        });
    });

    it('issues file path with mta/project pathPrefix are relative to workspace in MTA project', function (done) {
        var config = new ValidationConfig({
            validators: {
                "dummyJsValidator1": {
                    extensions: [".js", ".xsjs"]
                }
            }
        });
        sandbox.stub(validation, "__loadValidators").returns({
            'dummyJsValidator1': dummyJsValidator1
        });
        var projectName = "dummyProjModule";
        var mtaName = "MTADummyProj";
        var pathPrefix = path.join(path.sep, mtaName, projectName);
        var issues = validation.executeForProject(path.join(__dirname, "mock", mtaName, projectName), {pathPrefix:pathPrefix}, config, function (result) {
            console.log(result);
            var fileKey = Object.keys(result["dummyJsValidator1"]["issues"])[0];
            expect(fileKey).to.startWith(pathPrefix);
            expect(path.join(__dirname, "mock", fileKey)).to.startWith(path.join(__dirname, "mock", mtaName, projectName));//check file is relative to workspace of mta
            expect(fileKey).to.endWith(".js");
            done()
        });
    });

    it('execution with dummy js validator returning issue for file in root and in nested folder', function (done) {
        var config = new ValidationConfig({
            validators: {
                "dummyJsValidator1": {
                    extensions: [".js", ".xsjs"]
                }
            }
        });
        sandbox.stub(validation, "__loadValidators").returns({
            'dummyJsValidator1': dummyJsValidator1
        });
        var projectName = "dummyProj2";
        var pathPrefix = path.sep + projectName;
        var issues = validation.executeForProject(path.join(__dirname, "mock", projectName), pathPrefix, config, function (fullResult) {
            expect(fullResult).to.be.object;
            expect(fullResult["dummyJsValidator1"]).not.to.be.empty;
            var result = fullResult["dummyJsValidator1"]["issues"];

            expect(Object.keys(result)).to.have.length(2);
            var fileKey1 = Object.keys(result)[0];
            expect(fileKey1).to.equal(path.join(pathPrefix, "aaa.js"));
            expect(result[fileKey1]).to.have.length(3);
            var fileKey2 = Object.keys(result)[1];
            expect(fileKey2).to.equal(path.join(pathPrefix, "nested", "bbb.js"));
            expect(result[fileKey2]).to.have.length(3);
            done()
        });
    });

    it('execution with dummy js validator returning issue for file in root and ignores ignored folder', function (done) {
        var config = new ValidationConfig({
            ignoredPaths: [path.join(__dirname, "mock", "dummyProj2", "nested")],
            validators: {
                "dummyJsValidator1": {
                    extensions: [".js", ".xsjs"]
                }
            }
        });
        sandbox.stub(validation, "__loadValidators").returns({
            'dummyJsValidator1': dummyJsValidator1
        });
        var projectName = "dummyProj2";
        var pathPrefix = path.sep + projectName;
        var issues = validation.executeForProject(path.join(__dirname, "mock", projectName), pathPrefix, config, function (fullResult) {
            expect(fullResult).to.be.object;
            expect(fullResult["dummyJsValidator1"]).not.to.be.empty;
            var result = fullResult["dummyJsValidator1"]["issues"];

            expect(Object.keys(result)).to.have.length(1);
            var fileKey1 = Object.keys(result)[0];
            expect(fileKey1).to.equal(path.join(pathPrefix, "aaa.js"));
            expect(result[fileKey1]).to.exist;
            expect(result[fileKey1]).to.have.length(3);
            done()
        });
    });

    it('execution with 2 dummy js validator, returning issues of each for same file', function (done) {
        var config = new ValidationConfig({
            validators: {
                "dummyJsValidator1": {
                    extensions: [".js", ".xsjs"]
                },
                "dummyJsValidator2": {
                    extensions: [".js", ".xsjs"]
                }
            }
        });
        sandbox.stub(validation, "__loadValidators").returns(
            {
                'dummyJsValidator1': dummyJsValidator1,
                'dummyJsValidator2': dummyJsValidator2
            });
        var projectName = "dummyProj";
        var pathPrefix = path.sep + projectName;
        validation.executeForProject(path.join(__dirname, "mock", projectName), pathPrefix, config, function (fullResult) {
            expect(fullResult).to.be.object;
            expect(fullResult["dummyJsValidator1"]).not.to.be.empty;
            var result1 = fullResult["dummyJsValidator1"]["issues"];
            var result2 = fullResult["dummyJsValidator2"]["issues"];

            expect(result1).to.be.object;
            expect(result1).to.not.be.empty;
            expect(Object.keys(result1)).to.have.length(1);
            var fileKey1 = Object.keys(result1)[0];
            expect(result1[fileKey1]).to.exist;
            var fileIssues = result1[fileKey1];
            expect(fileIssues).to.have.length(3);

            expect(result2).to.be.object;
            expect(result2).to.not.be.empty;
            expect(Object.keys(result2)).to.have.length(1);
            var fileKey2 = Object.keys(result2)[0];
            expect(result2[fileKey2]).to.exist;
            var fileIssues = result2[fileKey2];
            expect(fileIssues).to.have.length(3);

            expect(fileKey1).to.equal(fileKey2);
            done();
        });
    });

    it('execution with 2 dummy js validator, returning only error issues for dummy 2', function (done) {
        var config = new ValidationConfig({
            validators: {
                "dummyJsValidator1": {
                    extensions: [".js", ".xsjs"]
                },
                "dummyJsValidator2": {
                    extensions: [".js", ".xsjs"],
                    filters: {levels: ["error"]}
                }
            }
        });
        sandbox.stub(validation, "__loadValidators").returns(
            {
                'dummyJsValidator1': dummyJsValidator1,
                'dummyJsValidator2': dummyJsValidator2
            });
        var projectName = "dummyProj";
        var pathPrefix = path.sep + projectName;
        validation.executeForProject(path.join(__dirname, "mock", projectName), pathPrefix, config, function (fullResult) {
            expect(fullResult).to.be.object;
            expect(fullResult["dummyJsValidator1"]).not.to.be.empty;
            var result1 = fullResult["dummyJsValidator1"]["issues"];
            var result2 = fullResult["dummyJsValidator2"]["issues"];

            expect(result1).to.be.object;
            expect(result1).to.not.be.empty;
            expect(Object.keys(result1)).to.have.length(1);
            var fileKey1 = Object.keys(result1)[0];
            expect(result1[fileKey1]).to.exist;
            var fileIssues = result1[fileKey1];
            expect(fileIssues).to.have.length(3);

            expect(result2).to.be.object;
            expect(result2).to.not.be.empty;
            expect(Object.keys(result2)).to.have.length(1);
            var fileKey2 = Object.keys(result2)[0];
            expect(result2[fileKey2]).to.exist;
            var fileIssues = result2[fileKey2];
            expect(fileIssues).to.have.length(1);

            expect(fileKey1).to.equal(fileKey2);
            done();
        });
    });

    it('execution with undefined validator returning no issue and writes to stderr', function (done) {
        var config = new ValidationConfig({
            ignoredPaths: [path.join(__dirname, "mock", "dummyProj2", "nested")],
            validators: {
                "unknownValidator": {
                    extensions: [".js", ".xsjs"]
                }
            }
        });
        var projectName = "dummyProj2";
        var pathPrefix = path.sep + projectName;
        var spy = sinon.spy(process.stderr, "write");
        var issues = validation.executeForProject(path.join(__dirname, "mock", projectName), pathPrefix, config, function (fullResult) {
            expect(fullResult).to.be.object;
            expect(fullResult["results"]).to.be.object;
            expect(fullResult["results"]).to.be.empty;
            expect(spy.calledOnce).to.be.true;
            done()
        });
    });

    afterEach(function () {
        sandbox.restore();
    });

});