var path = require("path");
var util = require("util");
var os = require("os");

/**
 * Created by I028014 on 31/05/2016.
 */
var fileUtils = require("./fileUtils");
var FileResource = require("./fileResource");
var ValidationMetadata = require("./validationMetadata");

function _loadValidators(validators) {
    var validationProviders = {};
    validators.forEach(function (providerName) {
        try {
            var provider = require(providerName);
            validationProviders[providerName] = provider;
        } catch (e) {
            process.stderr.write(util.format("Error in loading %s validator: %s. validate that it is installed" + os.EOL, providerName, e));
            //throw e;
            //TODO: err function
        }
    });
    return validationProviders;

}

function prepareValidatorCallsFunction(basePath, validationConfig, validationProviders) {
    var validationProvidersCall = {};
    Object.keys(validationProviders).forEach(function (providerName) {
        var extensions = validationConfig.getExtensions(providerName);
        var provider = validationProviders[providerName];
        validationProvidersCall[providerName] = function (done) {
            var validationMetadata = new ValidationMetadata(basePath, validationConfig.getLevels(providerName));
            fileUtils.listFilteredFiles(validationMetadata.getRootPath(), {
                extensions: extensions,
                ignoredPaths: validationConfig.getIgnoredPaths()
            }, function (files) {
                var fileResources = [];
                files.forEach(function (filePath) {
                    var fileResource = new FileResource(validationMetadata.getRootPath(), filePath);
                    fileResources.push(fileResource);
                });

                // debug is dev dependency - therefore encapsulated under flag
                if (process.env.DEBUG === 'code-validation') {
                    var debug = require('debug')('code-validation');
                    debug('start: %s', providerName);
                }
                var results = provider.validateFiles(validationMetadata, fileResources, {});
                if (process.env.DEBUG === 'code-validation') {
                    var totalSize = 0;
                    fileResources.forEach(function (file) {
                        var size = file.getSize();
                        totalSize += size;
                    });
                    debug('finish to run: %s with %d issues for:%d files with total size of: %d (Bytes)', providerName, results.issues.length, fileResources.length, totalSize);
                }
                done(results);
            });
        }
    });
    return validationProvidersCall;
}

function executeForProjectWithLoadedValidators(projectPath, options, validationConfig, validationProviders, done) {
    var validationProvidersCall = prepareValidatorCallsFunction(projectPath, validationConfig, validationProviders);

    var pendingValidations = Object.keys(validationProviders).length;
    var allResults = {};
    if (!pendingValidations) {
        done(allResults);
    }
    Object.keys(validationProvidersCall).forEach(function (providerName) {
        try {
            validationProvidersCall[providerName](function (results) {
                Promise.resolve(results).then(function(results){
                    resolveResults(projectPath, options, allResults, providerName, results);
                    if (!--pendingValidations) {
                        done(allResults);
                    }
                })
            });
        } catch (e) {
            process.stderr.write(util.format("Error in %s validator: %s" + os.EOL, providerName, e));
            //TODO: err function
        }
    });
}

function resolveResults(projectPath, options, allResults, providerName, results){
    var result = results || {};
    var issues = result.issues || [];
    var allIssues = {};

    issues.forEach(function (issue) {
        var filePath = issue.path;
        var resultPath = path.relative(projectPath, filePath);
        if (typeof options === 'string') {
            resultPath = path.join(options || "", resultPath);
        } else {
            resultPath = path.join(options && options.pathPrefix || "", resultPath);
        }
        issue.path = resultPath;
        allIssues[resultPath] = allIssues[resultPath] || [];
        allIssues[resultPath] = allIssues[resultPath].concat(issue);
    });
    allResults[providerName] = {"issues": allIssues};
}

function executeForProject(basePath, options, validationConfig, done) {
    var validationProviders = this.__loadValidators(validationConfig.getValidators());
    executeForProjectWithLoadedValidators(basePath, options, validationConfig, validationProviders, done);
}

module.exports = {
    executeForProject: executeForProject,
    __loadValidators: _loadValidators//public for testing purpose
}